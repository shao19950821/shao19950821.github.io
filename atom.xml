<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夏至微风</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nastublog.com/"/>
  <updated>2018-07-31T15:40:15.780Z</updated>
  <id>http://nastublog.com/</id>
  
  <author>
    <name>なつ初夏倾城</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试总结-追致科技</title>
    <link href="http://nastublog.com/2018/07/29/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-%E8%BF%BD%E8%87%B4%E7%A7%91%E6%8A%80/"/>
    <id>http://nastublog.com/2018/07/29/面试总结-追致科技/</id>
    <published>2018-07-29T13:49:15.000Z</published>
    <updated>2018-07-31T15:40:15.780Z</updated>
    
    <content type="html"><![CDATA[<p>本周末又华丽丽的跑去杭州了，面的是一家做电商领域的小公司，叫追致科技。<br><br>估计面试的是他们的老大吧，人还不错，约在星巴克面试的，还帮点了一份咖啡，好感度加分，然后和我讲他也是技术出身，所以对于技术比较重视，整个面试下来像是朋友之间谈话交流一般，没有过多的涉及到技术的问题，主要是问平时都喜欢看哪些书，通过看什么学习，然后有什么看法，中间穿插着项目和一些技术上的问题，还有自己对现在这份工作的感受，整体感觉还不错。<br><br>主要问的题目也就是根据简历上来，估计是看到我简历上写了一些前端的技术，先是问了Ajax是一个什么样的技术，然后问了jQuery选择方法和选择器，然后html、css、js分别承担了什么样的职责？因为我对于前端也不怎么熟悉，主要粗略的回答了一下，jQuery的选择器也就了解几个简单的选择器，对于组合选择器也是不太了解，之后可以熟悉一下。<br>然后就是问了数据库的问题，having一般用在什么时候，说说你对sql调优的理解，然后就是数据库索引的原理，这边sql调优刚刚有看过，po个链接在这吧。<br><br><a href="http://www.jfox.info/SQL-you-hua.html" target="_blank" rel="noopener">SQL优化</a><br></p><p>我主要也就是讲了不要随便使用select *以及不要随便使用会放弃索引而采取全表扫描的关键字，比如 in or，以及在经常需要排序的字段上添加索引这样的方法，这方面还是要多多看文章实践一下。<br><br>至于索引的原理，大概也就是停留在知道其是用B+树和变种B+树实现，通过这样的一个数据结构能够更快的定位到需要的位置这样的概念，之后有时间估计也会去学习一下B+树的数据结构。<br>然后Java的话问了一下Java8的新特性，以及你理解的函数式编程，他和面向对象编程有说么区别，这里我没有回答清楚，面试官给出了说法，主要就是函数式编程数据是不可改变的，之后准备去了解一下。<br>然后本次面试主要的大头也就是对之前笔试题做一个重构，笔试题虽然简单，但是他想考察的主要是一个人的设计能力和面向对象思想，这点估计是他比较看重的，这里po一下笔试题和我的第一版程序吧。<br><br>笔试题我也就记得住大概，一个平台，左下角定义是(0,0),输入右上角的最大坐标，然后输入一个漫步车的x,y坐标以及方向W、E、S、N，然后输入一串移动指令，L表示漫步车方向左转90°，R表示漫步车方向右转90°，M表示漫步车移动朝当前方向移动一格，输入指令后，显示出当前漫步车的位置。<br><br>大概就是这样吧，po一下我的第一版代码，可能有拙劣之处:<br><br>这是定义的漫步车对象:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 漫游车</span><br><span class="line"> * @Date: Created in 12:17 2018/7/19</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class RangeRovers &#123;</span><br><span class="line"></span><br><span class="line">    private int x; // 漫游车x坐标</span><br><span class="line"></span><br><span class="line">    private int y; // 漫游车y坐标</span><br><span class="line"></span><br><span class="line">    private Position position;</span><br><span class="line"></span><br><span class="line">    public int getX() &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setX(int x) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getY() &#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setY(int y) &#123;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Position getPosition() &#123;</span><br><span class="line">        return position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPosition(Position position) &#123;</span><br><span class="line">        this.position = position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RangeRovers(int x, int y, String position) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.position = Position.valueOf(position);</span><br><span class="line">        &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">            System.out.println(&quot;初始化方向错误，请输入正确方向代码&quot;);</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;RangeRovers&#123;&quot; +</span><br><span class="line">                &quot;x=&quot; + x +</span><br><span class="line">                &quot;, y=&quot; + y +</span><br><span class="line">                &quot;, position=&quot; + position +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为方向是定义好的常量，我们采取枚举的模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 方向</span><br><span class="line"> * @Date: Created in 12:16 2018/7/19</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public enum Position &#123;</span><br><span class="line">    E,</span><br><span class="line">    S,</span><br><span class="line">    W,</span><br><span class="line">    N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是定义的平台的对象，因为平台涉及到最大X、Y值和最小X、Y值，当漫步车移动到临界时，便无法再次移动。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 平台</span><br><span class="line"> * @Date: Created in 12:28 2018/7/19</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class PlatForm &#123;</span><br><span class="line"></span><br><span class="line">    private final int minX = 0; // 左下角横坐标</span><br><span class="line"></span><br><span class="line">    private final int minY = 0; // 左下角纵坐标</span><br><span class="line"></span><br><span class="line">    private int maxX; // 右上角横坐标</span><br><span class="line"></span><br><span class="line">    private int maxY; // 右上角纵坐标</span><br><span class="line"></span><br><span class="line">    public int getMinX() &#123;</span><br><span class="line">        return minX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getMinY() &#123;</span><br><span class="line">        return minY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getMaxX() &#123;</span><br><span class="line">        return maxX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMaxX(int maxX) &#123;</span><br><span class="line">        this.maxX = maxX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getMaxY() &#123;</span><br><span class="line">        return maxY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMaxY(int maxY) &#123;</span><br><span class="line">        this.maxY = maxY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PlatForm(int maxX, int maxY) &#123;</span><br><span class="line">        this.maxX = maxX;</span><br><span class="line">        this.maxY = maxY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;PlatForm&#123;&quot; +</span><br><span class="line">                &quot;minX=&quot; + minX +</span><br><span class="line">                &quot;, minY=&quot; + minY +</span><br><span class="line">                &quot;, maxX=&quot; + maxX +</span><br><span class="line">                &quot;, maxY=&quot; + maxY +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了一个漫游车移动方法的接口(这里就是设计的不合理之处了，怎么不合理，之后会提到)。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 漫游者移动接口</span><br><span class="line"> * @Date: Created in 12:20 2018/7/19</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public interface IRangeRoversMove &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  漫步车移动方法</span><br><span class="line">     * @param rangeRovers 漫步车对象</span><br><span class="line">     * @param platForm 平台对象</span><br><span class="line">     * @param moveCommand 移动指令</span><br><span class="line">     */</span><br><span class="line">    void rangeRoversMove(RangeRovers rangeRovers, PlatForm platForm, String moveCommand);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义了实现漫游车移动接口的漫游车指令接收器，里面实现了漫步车移动的通用方法，并设置了两个private方法，分别是漫步车根据不同指令做出的改变方向的方法和移动方法。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 漫步车指令接收器</span><br><span class="line"> * @Date: Created in 12:46 2018/7/19</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class RangeRoversCommandReceiver implements IRangeRoversMove &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void rangeRoversMove(RangeRovers rangeRovers, PlatForm platForm, String moveCommand) &#123;</span><br><span class="line"></span><br><span class="line">        char[] moveCommandArray = moveCommand.toCharArray();</span><br><span class="line"></span><br><span class="line">        for (int i = 0;i&lt;moveCommandArray.length;i++) &#123;</span><br><span class="line">            char moveCommandChar = moveCommandArray[i];</span><br><span class="line">            if (&quot;M&quot;.equalsIgnoreCase(String.valueOf(moveCommandChar))) &#123;</span><br><span class="line">                this.stepMove(rangeRovers, platForm, moveCommand.toString());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.postionChange(rangeRovers, String.valueOf(moveCommandChar));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 方向改变函数</span><br><span class="line">     *</span><br><span class="line">     * @param rangeRovers          漫步车对象</span><br><span class="line">     * @param changePositonCommand 方向改变命令</span><br><span class="line">     */</span><br><span class="line">    private void postionChange(RangeRovers rangeRovers, String changePositonCommand) &#123;</span><br><span class="line">        if (&quot;L&quot;.equalsIgnoreCase(changePositonCommand)) &#123;</span><br><span class="line">            switch (rangeRovers.getPosition()) &#123;</span><br><span class="line">                case E:</span><br><span class="line">                    rangeRovers.setPosition(Position.N);</span><br><span class="line">                    break;</span><br><span class="line">                case N:</span><br><span class="line">                    rangeRovers.setPosition(Position.W);</span><br><span class="line">                    break;</span><br><span class="line">                case W:</span><br><span class="line">                    rangeRovers.setPosition(Position.S);</span><br><span class="line">                    break;</span><br><span class="line">                case S:</span><br><span class="line">                    rangeRovers.setPosition(Position.E);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (&quot;R&quot;.equalsIgnoreCase(changePositonCommand)) &#123;</span><br><span class="line">            switch (rangeRovers.getPosition()) &#123;</span><br><span class="line">                case E:</span><br><span class="line">                    rangeRovers.setPosition(Position.S);</span><br><span class="line">                    break;</span><br><span class="line">                case S:</span><br><span class="line">                    rangeRovers.setPosition(Position.W);</span><br><span class="line">                    break;</span><br><span class="line">                case W:</span><br><span class="line">                    rangeRovers.setPosition(Position.N);</span><br><span class="line">                    break;</span><br><span class="line">                case N:</span><br><span class="line">                    rangeRovers.setPosition(Position.E);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 漫步车移动方法</span><br><span class="line">     *</span><br><span class="line">     * @param rangeRovers     漫步车对象</span><br><span class="line">     * @param platForm        平台对象</span><br><span class="line">     * @param stepMoveCommand 移动指令</span><br><span class="line">     */</span><br><span class="line">    private void stepMove(RangeRovers rangeRovers, PlatForm platForm, String stepMoveCommand) &#123;</span><br><span class="line">        switch (rangeRovers.getPosition()) &#123;</span><br><span class="line">            case S:</span><br><span class="line">                if (rangeRovers.getY() &gt; platForm.getMinY()) &#123;</span><br><span class="line">                    rangeRovers.setY(rangeRovers.getY()-1);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case N:</span><br><span class="line">                if (rangeRovers.getY() &lt; platForm.getMaxY()) &#123;</span><br><span class="line">                    rangeRovers.setY(rangeRovers.getY()+1);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case W:</span><br><span class="line">                if (rangeRovers.getX() &gt; platForm.getMinX()) &#123;</span><br><span class="line">                    rangeRovers.setX(rangeRovers.getX()-1);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case E:</span><br><span class="line">                if (rangeRovers.getX() &lt; platForm.getMaxX()) &#123;</span><br><span class="line">                    rangeRovers.setX(rangeRovers.getX()+1);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写了一个Client测试类来测试结果:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;请输入平台右上角坐标&quot;);</span><br><span class="line"></span><br><span class="line">        int maxX = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        int maxY = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        PlatForm platForm = new PlatForm(maxX, maxY);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;初始化探索平台完成,信息是:&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(platForm.toString());</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.println(&quot;请输入漫步车初始坐标和初始方向&quot;);</span><br><span class="line"></span><br><span class="line">            int rangeRoversX = sc.nextInt();</span><br><span class="line"></span><br><span class="line">            int rangeRoversY = sc.nextInt();</span><br><span class="line"></span><br><span class="line">            String rangeRoversPostion = sc.nextLine().trim();</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;初始化漫步车&quot;);</span><br><span class="line"></span><br><span class="line">            RangeRovers rangeRovers = new RangeRovers(rangeRoversX, rangeRoversY, rangeRoversPostion);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;初始化漫步车完成,信息是:&quot;);</span><br><span class="line"></span><br><span class="line">            System.out.println(rangeRovers.toString());</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;请输入移动指令:&quot;);</span><br><span class="line"></span><br><span class="line">            String moveCommand = sc.nextLine().trim();</span><br><span class="line"></span><br><span class="line">            RangeRoversCommandReceiver rangeRoversCommandReceiver = new RangeRoversCommandReceiver();</span><br><span class="line"></span><br><span class="line">            rangeRoversCommandReceiver.rangeRoversMove(rangeRovers, platForm, moveCommand);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;当前漫步车信息&quot;);</span><br><span class="line"></span><br><span class="line">            System.out.println(rangeRovers.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行，具体结果如下<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">请输入平台右上角坐标</span><br><span class="line">5 5 </span><br><span class="line">初始化探索平台完成,信息是:</span><br><span class="line">PlatForm&#123;minX=0, minY=0, maxX=5, maxY=5&#125;</span><br><span class="line">请输入漫步车初始坐标和初始方向</span><br><span class="line">1 1 E</span><br><span class="line">初始化漫步车</span><br><span class="line">初始化漫步车完成,信息是:</span><br><span class="line">RangeRovers&#123;x=1, y=1, position=E&#125;</span><br><span class="line">请输入移动指令:</span><br><span class="line">LMMRMMLMRM</span><br><span class="line">当前漫步车信息</span><br><span class="line">RangeRovers&#123;x=4, y=4, position=E&#125;</span><br><span class="line">请输入漫步车初始坐标和初始方向</span><br></pre></td></tr></table></figure><p>面试官说，这段代码，仔细看了一下，好像封装了很多类，但是，其实并没有体现出面向对象的思想，为什么这么说呢?<br><br>第一，漫步车既然封装了一个对象，但这个对象，仅仅是涉及到了漫步车的初始定义，X轴坐标、Y轴坐标、初始方向，这样的做法是毫无意义的。我想了一下，说可以把漫步车封装成一个抽象类，将通用的移动方法定义为抽象方法，然后将改变方向的方法和移动方法放在了移动接口里，然后定义具体的漫步车继承抽象漫步车并实现接口，大概就是如下的代码。<br></p><p>先是一个抽象的漫步车：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 漫游车</span><br><span class="line"> * @Date: Created in 12:17 2018/7/19</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public abstract class AbstractRangeRover &#123;</span><br><span class="line"></span><br><span class="line">    private int x; // 漫游车x坐标</span><br><span class="line"></span><br><span class="line">    private int y; // 漫游车y坐标</span><br><span class="line"></span><br><span class="line">    private Position position;</span><br><span class="line"></span><br><span class="line">    public int getX() &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setX(int x) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getY() &#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setY(int y) &#123;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Position getPosition() &#123;</span><br><span class="line">        return position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPosition(Position position) &#123;</span><br><span class="line">        this.position = position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AbstractRangeRover(int x, int y, String position) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.position = Position.valueOf(position);</span><br><span class="line">        &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">            System.out.println(&quot;初始化方向错误，请输入正确方向代码&quot;);</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;RangeRovers&#123;&quot; +</span><br><span class="line">                &quot;x=&quot; + x +</span><br><span class="line">                &quot;, y=&quot; + y +</span><br><span class="line">                &quot;, position=&quot; + position +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void rangeRoversMove(PlatForm platForm, String moveCommand);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后仍旧是漫步车移动接口<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 漫游车移动接口</span><br><span class="line"> * @Date: Created in 12:20 2018/7/19</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public interface IRangeRoversMove &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 漫步车改变方向方法</span><br><span class="line">     *</span><br><span class="line">     * @param changePositonCommand 移动指令</span><br><span class="line">     */</span><br><span class="line">    void postionChange(String changePositonCommand);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 漫步车移动方法</span><br><span class="line">     * @param platForm</span><br><span class="line">     */</span><br><span class="line">    void stepMove(PlatForm platForm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是具体的漫步车<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 具体漫步车</span><br><span class="line"> * @Date: Created in 12:46 2018/7/19</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class ConcreteRangeRover extends AbstractRangeRover implements IRangeRoversMove &#123;</span><br><span class="line"></span><br><span class="line">    public ConcreteRangeRover(int x,int y,String position)&#123;</span><br><span class="line">        super(x,y,position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void rangeRoversMove(PlatForm platForm, String moveCommand) &#123;</span><br><span class="line"></span><br><span class="line">        char[] moveCommandArray = moveCommand.toCharArray();</span><br><span class="line"></span><br><span class="line">        for (int i = 0;i&lt;moveCommandArray.length;i++) &#123;</span><br><span class="line">            char moveCommandChar = moveCommandArray[i];</span><br><span class="line">            if (&quot;M&quot;.equalsIgnoreCase(String.valueOf(moveCommandChar))) &#123;</span><br><span class="line">                this.stepMove( platForm);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.postionChange( String.valueOf(moveCommandChar));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 方向改变函数</span><br><span class="line">     * @param changePositonCommand 方向改变命令</span><br><span class="line">     */</span><br><span class="line">    public void postionChange(String changePositonCommand) &#123;</span><br><span class="line">        if (&quot;L&quot;.equalsIgnoreCase(changePositonCommand)) &#123;</span><br><span class="line">            switch (this.getPosition()) &#123;</span><br><span class="line">                case E:</span><br><span class="line">                    this.setPosition(Position.N);</span><br><span class="line">                    break;</span><br><span class="line">                case N:</span><br><span class="line">                    this.setPosition(Position.W);</span><br><span class="line">                    break;</span><br><span class="line">                case W:</span><br><span class="line">                    this.setPosition(Position.S);</span><br><span class="line">                    break;</span><br><span class="line">                case S:</span><br><span class="line">                    this.setPosition(Position.E);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (&quot;R&quot;.equalsIgnoreCase(changePositonCommand)) &#123;</span><br><span class="line">            switch (this.getPosition()) &#123;</span><br><span class="line">                case E:</span><br><span class="line">                    this.setPosition(Position.S);</span><br><span class="line">                    break;</span><br><span class="line">                case S:</span><br><span class="line">                    this.setPosition(Position.W);</span><br><span class="line">                    break;</span><br><span class="line">                case W:</span><br><span class="line">                    this.setPosition(Position.N);</span><br><span class="line">                    break;</span><br><span class="line">                case N:</span><br><span class="line">                    this.setPosition(Position.E);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 漫步车移动方法</span><br><span class="line">     * @param platForm        平台对象</span><br><span class="line">     */</span><br><span class="line">    public void stepMove(PlatForm platForm) &#123;</span><br><span class="line">        switch (this.getPosition()) &#123;</span><br><span class="line">            case S:</span><br><span class="line">                if (this.getY() &gt; platForm.getMinY()) &#123;</span><br><span class="line">                    this.setY(this.getY()-1);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case N:</span><br><span class="line">                if (this.getY() &lt; platForm.getMaxY()) &#123;</span><br><span class="line">                    this.setY(this.getY()+1);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case W:</span><br><span class="line">                if (this.getX() &gt; platForm.getMinX()) &#123;</span><br><span class="line">                    this.setX(this.getX()-1);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case E:</span><br><span class="line">                if (this.getX() &lt; platForm.getMaxX()) &#123;</span><br><span class="line">                    this.setX(this.getX()+1);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看似对上面代码进行的改造，可还是有不合理的地方：<br><br>第一点，改变方向和移动的方法访问域因为实现了接口，必须是public，这是不合理的，外部按道理只需要调用通用的移动方法就行了，所以并没有必要暴露具体的改变方向的方法和移动的方法给外部访问;<br><br>第二点，这道题的业务场景并不需要定义接口，接口是什么，是对行为的一种抽象，而此题，因为漫步车不仅有抽象的移动方法，还有他自己的属性和默认方法，所以并没有采用接口的设计，而是采用了抽象类，所以，只需要将所有的移动方法定义为抽象的即可。<br><br>第三点，定义漫步车也并没有抛出异常的必要(顺带这里问了一下Java异常的分类，以及RuntimeException和非RuntimeException得区别)。<br></p><p>基于以上几点，我又说了一下自己的思路，这里就不在po代码了，大致说一下吧，因为我们不需要将改变方向和移动的方法给外部访问，外部只需要调用通用的移动方法，传入指令，通用的方法会自动判断每一个指令应该调用什么方法，所以，我们在设计抽象方法的时候只需要将改变方向和移动的方法的访问域设为protected就行，因为面试官之后还有事情，我也还要赶回上海时，所以这大概就是我和面试官聊得最后的思路。<br><br>临走之前，面试官让我回去再优化优化这段逻辑，我思考了一下，这大概可以用到我最近刚看过的模板方法模式，通用的移动方法就是模板方法，并不需要在具体的类中去实现他，因为漫步车现在涉及的操作无非就是移动和改变方向，而之后需求变更，变更的可能会使指令所代表的移动的长度以及改变方向的方法，而对于整体的逻辑改动可能会较小，所以可以将通用的方法设计成模板方法写在抽象类里，也就是定义了一个操作算法的框架，而具体的方法延迟到子类里去执行，这大概就是模板方法模式。<br><br>这里还涉及到了指令的判断，于是我们可以在抽象类中再封装一个指令判断的默认方法，如果具体的指令判断有改变，则在子类中重写该方法，这个判断指令的方法可以称之为钩子方法。<br><br>这大概就是我的最终思路，下面看一下具体的代码实现。<br><br>抽象的漫步车<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 漫游车</span><br><span class="line"> * @Date: Created in 12:17 2018/7/19</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public abstract class AbstractRangeRover &#123;</span><br><span class="line"></span><br><span class="line">    private int x; // 漫游车x坐标</span><br><span class="line"></span><br><span class="line">    private int y; // 漫游车y坐标</span><br><span class="line"></span><br><span class="line">    private Position position;</span><br><span class="line"></span><br><span class="line">    public int getX() &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setX(int x) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getY() &#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setY(int y) &#123;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Position getPosition() &#123;</span><br><span class="line">        return position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPosition(Position position) &#123;</span><br><span class="line">        this.position = position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AbstractRangeRover(int x, int y, String position) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">        this.position = Position.valueOf(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;RangeRovers&#123;&quot; +</span><br><span class="line">                &quot;x=&quot; + x +</span><br><span class="line">                &quot;, y=&quot; + y +</span><br><span class="line">                &quot;, position=&quot; + position +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 漫步车移动模板方法</span><br><span class="line">     * @param platForm</span><br><span class="line">     * @param command</span><br><span class="line">     */</span><br><span class="line">    public  void rangeRoversMove(PlatForm platForm, String command)&#123;</span><br><span class="line">        char[] commandArray = command.toCharArray();</span><br><span class="line">        for (int i = 0;i&lt;commandArray.length;i++) &#123;</span><br><span class="line">            char commandChar = commandArray[i];</span><br><span class="line">            if (this.isStepMove(String.valueOf(commandChar))) &#123;</span><br><span class="line">                this.stepMove(platForm,String.valueOf(commandChar));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.postionChange(String.valueOf(commandChar));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected abstract void postionChange(String changePositonCommand);</span><br><span class="line"></span><br><span class="line">    protected abstract void stepMove(PlatForm platForm, String moveCommand);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 钩子方法，默认M代表移动，其他代表改变方向，如果具体的构造车不同，可以重写钩子方法</span><br><span class="line">     * @param command</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    protected boolean isStepMove(String command) &#123;</span><br><span class="line">        if (&quot;M&quot;.equalsIgnoreCase(command)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中，通用的模板方法封装了具体的算法思路，也就是通过钩子方法确定是调用改变方向的方法还是移动的方法,然后抛出异常没有意义(这里建立在ACM的思想上，输入的数据都是合法的，如果可能存在不合法的数据，建议是封装初始化方法，初始化失败后重新调用并给出提示)<br></p><p>然后是具体的漫步车<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 具体漫步车</span><br><span class="line"> * @Date: Created in 12:46 2018/7/19</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class ConcreteRangeRover extends AbstractRangeRover &#123;</span><br><span class="line"></span><br><span class="line">    public ConcreteRangeRover(int x,int y,String position)&#123;</span><br><span class="line">        super(x,y,position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 方向改变函数</span><br><span class="line">     * @param changePositonCommand 方向改变命令</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void postionChange(String changePositonCommand) &#123;</span><br><span class="line">        if (&quot;L&quot;.equalsIgnoreCase(changePositonCommand)) &#123;</span><br><span class="line">            switch (this.getPosition()) &#123;</span><br><span class="line">                case E:</span><br><span class="line">                    this.setPosition(Position.N);</span><br><span class="line">                    break;</span><br><span class="line">                case N:</span><br><span class="line">                    this.setPosition(Position.W);</span><br><span class="line">                    break;</span><br><span class="line">                case W:</span><br><span class="line">                    this.setPosition(Position.S);</span><br><span class="line">                    break;</span><br><span class="line">                case S:</span><br><span class="line">                    this.setPosition(Position.E);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (&quot;R&quot;.equalsIgnoreCase(changePositonCommand)) &#123;</span><br><span class="line">            switch (this.getPosition()) &#123;</span><br><span class="line">                case E:</span><br><span class="line">                    this.setPosition(Position.S);</span><br><span class="line">                    break;</span><br><span class="line">                case S:</span><br><span class="line">                    this.setPosition(Position.W);</span><br><span class="line">                    break;</span><br><span class="line">                case W:</span><br><span class="line">                    this.setPosition(Position.N);</span><br><span class="line">                    break;</span><br><span class="line">                case N:</span><br><span class="line">                    this.setPosition(Position.E);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 漫步车移动方法</span><br><span class="line">     * @param platForm</span><br><span class="line">     * @param moveCommand(这个参数还是有必要的我觉得，因为以后可能对移动的命令有所扩展，既然是针对命令移动，</span><br><span class="line">     * 我认为传入命令参数是有必要的，虽然现在的业务移动逻辑只有M一种，不保证需求变更后会不会增加)</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line"></span><br><span class="line">    protected void stepMove(PlatForm platForm,String moveCommand) &#123;</span><br><span class="line">        switch (this.getPosition()) &#123;</span><br><span class="line">            case S:</span><br><span class="line">                if (this.getY() &gt; platForm.getMinY()) &#123;</span><br><span class="line">                    this.setY(this.getY()-1);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case N:</span><br><span class="line">                if (this.getY() &lt; platForm.getMaxY()) &#123;</span><br><span class="line">                    this.setY(this.getY()+1);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case W:</span><br><span class="line">                if (this.getX() &gt; platForm.getMinX()) &#123;</span><br><span class="line">                    this.setX(this.getX()-1);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case E:</span><br><span class="line">                if (this.getX() &lt; platForm.getMaxX()) &#123;</span><br><span class="line">                    this.setX(this.getX()+1);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象漫步车里定义的改变方向方法和移动方法都延迟到了具体类里实现，这就是模板方式的好处，在不改变原有算法的结构的情况下，可以重定义该算法的某些特定步骤。<br></p><p>最后还是测试类测试一下<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;请输入平台右上角坐标&quot;);</span><br><span class="line"></span><br><span class="line">        int maxX = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        int maxY = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        PlatForm platForm = new PlatForm(maxX, maxY);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;初始化探索平台完成,信息是:&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(platForm.toString());</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.println(&quot;请输入漫步车初始坐标和初始方向&quot;);</span><br><span class="line"></span><br><span class="line">            int rangeRoversX = sc.nextInt();</span><br><span class="line"></span><br><span class="line">            int rangeRoversY = sc.nextInt();</span><br><span class="line"></span><br><span class="line">            String rangeRoversPostion = sc.nextLine().trim();</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;初始化漫步车&quot;);</span><br><span class="line"></span><br><span class="line">            ConcreteRangeRover concreteRangeRover = new ConcreteRangeRover(rangeRoversX, rangeRoversY, rangeRoversPostion);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;初始化漫步车完成,信息是:&quot;);</span><br><span class="line"></span><br><span class="line">            System.out.println(concreteRangeRover.toString());</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;请输入移动指令:&quot;);</span><br><span class="line"></span><br><span class="line">            String moveCommand = sc.nextLine().trim();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            concreteRangeRover.rangeRoversMove(platForm, moveCommand);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;当前漫步车信息&quot;);</span><br><span class="line"></span><br><span class="line">            System.out.println(concreteRangeRover.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">请输入平台右上角坐标</span><br><span class="line">5 5</span><br><span class="line">初始化探索平台完成,信息是:</span><br><span class="line">PlatForm&#123;minX=0, minY=0, maxX=5, maxY=5&#125;</span><br><span class="line">请输入漫步车初始坐标和初始方向</span><br><span class="line">1 1 E</span><br><span class="line">初始化漫步车</span><br><span class="line">初始化漫步车完成,信息是:</span><br><span class="line">RangeRovers&#123;x=1, y=1, position=E&#125;</span><br><span class="line">请输入移动指令:</span><br><span class="line">LMMRMMLMRM</span><br><span class="line">当前漫步车信息</span><br><span class="line">RangeRovers&#123;x=4, y=4, position=E&#125;</span><br><span class="line">请输入漫步车初始坐标和初始方向</span><br></pre></td></tr></table></figure></p><p>这道题目虽然简单，可细细想起来，还是有很多值得回味的地方的，所以说，平时编写代码的时候，多思考多动脑，或许会有不一样的收获，这里用到了设计模式里的模板方法模式，之后也会写一篇博客总结一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本周末又华丽丽的跑去杭州了，面的是一家做电商领域的小公司，叫追致科技。&lt;br&gt;&lt;br&gt;估计面试的是他们的老大吧，人还不错，约在星巴克面试的，还帮点了一份咖啡，好感度加分，然后和我讲他也是技术出身，所以对于技术比较重视，整个面试下来像是朋友之间谈话交流一般，没有过多的涉及到技
      
    
    </summary>
    
      <category term="随笔" scheme="http://nastublog.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="面试" scheme="http://nastublog.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-模板方法模式(Template)</title>
    <link href="http://nastublog.com/2018/07/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-Template/"/>
    <id>http://nastublog.com/2018/07/29/设计模式-模板方法模式-Template/</id>
    <published>2018-07-29T13:46:21.000Z</published>
    <updated>2018-07-29T13:49:38.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;
      
    
    </summary>
    
      <category term="设计模式" scheme="http://nastublog.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://nastublog.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>开发也要懂点算法(一)-AStar寻路算法</title>
    <link href="http://nastublog.com/2018/07/29/%E5%BC%80%E5%8F%91%E4%B9%9F%E8%A6%81%E6%87%82%E7%82%B9%E7%AE%97%E6%B3%95-%E4%B8%80-A-%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
    <id>http://nastublog.com/2018/07/29/开发也要懂点算法-一-A-寻路算法/</id>
    <published>2018-07-28T16:05:44.000Z</published>
    <updated>2018-07-31T15:40:34.566Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="算法" scheme="http://nastublog.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AStar" scheme="http://nastublog.com/categories/%E7%AE%97%E6%B3%95/AStar/"/>
    
    
      <category term="算法" scheme="http://nastublog.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>面试总结-有赞电面</title>
    <link href="http://nastublog.com/2018/07/28/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-%E6%9C%89%E8%B5%9E%E7%94%B5%E9%9D%A2/"/>
    <id>http://nastublog.com/2018/07/28/面试总结-有赞电面/</id>
    <published>2018-07-28T07:00:21.000Z</published>
    <updated>2018-07-31T15:39:11.348Z</updated>
    
    <content type="html"><![CDATA[<p>昨晚接到了有赞的电话面试，唉，又是被虐的一次经历。整体上来说，自我感觉Java基础方面经过一星期的突击，还算有点成效，但是一涉及到Spring框架的方面，就一无所知了，面试完了，照例写一个小总结吧。<br>大概是6点半左右接到的面试电话，按照惯例的3分钟自我介绍，介绍完了后面试官就向我介绍了他们部门的情况，主要是做OA的，说是业务结构比较复杂，还有不会涉及到高并发，因为我在介绍的时候说过自己想接触高并发这一块，然后就开始面试过程了。<br>主要的话还是分为框架部分和Java基础部分网络顺带也提了一下，就根据自己的印象写一写问到的题目吧。<br>1.Spring Scope域有哪几种，默认是什么，分别代表了什么?（我就知道一个Singleton，而且模模糊糊的）<br>2.Spring bean创建后就会一直存在么，如果不是，什么时候销毁?<br>3.Spring的拦截器有了解过么，在什么地方使用过?(我就大致说了一下Spring的拦截器也是基于AOP实现的，然后我只使用过Mybatis的拦截器，而且也说不出个所以然来，只知道大致的实现方法)<br>4.Spring Aop了解过么?Advice有哪几种类型<br>5.Aop是基于什么设计模式实现的?动态代理有哪几种?<br>6.ArrayList和LinkedList的区别?<br>7.Arrays.asList()了解过么?这样创建List和new有什么不同?创建出来的List能进行add和remove操作么?(我说Array.asList()是抽象工厂的方法，也不知道对不对)<br>8.HashMap的底层原理?(这个最近刚好看过，就balabala说了一大堆，最尴尬的是，Entry被我说成了Node)<br>9.HashMap的负载因子为什么设置成0.75，设成1能存更多么?<br>10.HashMap index冲突时采用的是头插还是尾插，为什么?<br>总的来说，面试结果不尽如人意，框架部分模模糊糊，想回答回答不出来，只能大概描述一下，而且还不知道对不对，Java基础部分，涉及到为什么这样设计的时候，也回答的模棱两可，感觉自己就是为了应付面试去看这些原理，并没有好好想想为什么这么设计，借用面试官的一句话来说，感觉你这些东西好像都用过，但是说起来的时候，原理都不太了解。<br>借由这两次面试，也思考了一下自己未来的职业发展方向，暂时也比较模糊，但是，本身对于J2EE的开发不太感兴趣，可能还是想往更深的道路走吧，所以打算了一下，准备以后更多的花时间在Java基础上，比如源码的研究，然后适当的看看算法和设计模式，尽量保证一周看一种设计模式和算法吧，跳槽完成后也准备去POJ上刷刷算法题了，反正，先做准备吧，指不定啥时候就用上了呢，哈哈哈哈，fighting 少年。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨晚接到了有赞的电话面试，唉，又是被虐的一次经历。整体上来说，自我感觉Java基础方面经过一星期的突击，还算有点成效，但是一涉及到Spring框架的方面，就一无所知了，面试完了，照例写一个小总结吧。&lt;br&gt;大概是6点半左右接到的面试电话，按照惯例的3分钟自我介绍，介绍完了后
      
    
    </summary>
    
      <category term="随笔" scheme="http://nastublog.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="面试" scheme="http://nastublog.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>UML类图总结</title>
    <link href="http://nastublog.com/2018/07/28/UML%E7%B1%BB%E5%9B%BE%E6%80%BB%E7%BB%93/"/>
    <id>http://nastublog.com/2018/07/28/UML类图总结/</id>
    <published>2018-07-28T06:56:49.000Z</published>
    <updated>2018-07-31T15:39:24.623Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写有关设计模式的Blog，但涉及到UML类图这方面的话，总是从网上下载现成的图片，这也导致了我对UML类图这一方面，并没有一个很深的印象，所以决定写这么一篇文章，加深一下自己对UML类图的印象。</p><h1 id="为什么需要UML图"><a href="#为什么需要UML图" class="headerlink" title="为什么需要UML图"></a>为什么需要UML图</h1><p>UML：Unified Modeling Language，即统一建模语言，简单地说就是一种有特殊用处的语言<br>我们做项目的需求分析，最开始往往得到的是一堆文字，往往我们对业务逻辑一无所知，这时候，我们迫切需要的就是理清这些业务概念以及它们之间的关系，这时候，UML类图就显得尤为重要了。对于现在的我菜来说，让我们做的可能性不大，但至少能看懂是必要的。</p><h1 id="什么"><a href="#什么" class="headerlink" title="什么"></a>什么</h1><h1 id="UML类的工具"><a href="#UML类的工具" class="headerlink" title="UML类的工具"></a>UML类的工具</h1><p>Visio是一款不错的工具，还有一款不错的在线编辑工具，ProgressOn，这里贴上链接。<br><a href="https://www.processon.com/" target="_blank" rel="noopener">ProgressOn</a></p><h1 id="怎么画UML类图"><a href="#怎么画UML类图" class="headerlink" title="怎么画UML类图"></a>怎么画UML类图</h1><p>在类图中一共包含了以下几种元素:类、接口以及类之间的关系。</p><h2 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>在面向对象编程中,类是对现实世界中一组具有相同特征的物体的抽象。下面是一个简单的类图。<br><img src="/2018/07/28/UML类图总结/Class.png" alt="类图"><br>其中，+ - # 代表的是作用域，+代表public，-代表private，#代表protected。<br>:后跟的则是返回类型。<br>如果类是抽象类，名称用斜体表示，同理，如果方法是抽象方法，也用斜体表示。<br>属性的表示方式为：【可见性】【属性名称】：【类型】={缺省值，可选}<br>方法的表示方式为：【可见性】【方法名称】（【参数列表】）：【类型】<br>上面类图对应的代码如下:</p><pre><code>public class Student {    public String name;    private Integer age;    protected String sex;    public void work1() {    }    private void work2() {    }    protected String work3(String age) {        return age;    }}</code></pre><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口是一种特殊的类，具有类的结构但不可被实例化，只可以被实现（继承）。在UML中，接口使用一个带有名称的小圆圈来进行表示(也可以通过在名字上标注《interface》，ProgressOn因为小圆圈不显示，我们采取这种形式)。<br>注意，接口中的方法都是abstract的，所以我们采取斜体模式。</p><p>#参考<br><a href="http://www.uml.org.cn/oobject/201610282.asp" target="_blank" rel="noopener">详解UML图之类图</a><br><a href="https://www.awaimai.com/patterns/uml" target="_blank" rel="noopener">UML类图详解</a><br><a href="http://www.cnblogs.com/edisonchou/p/3977829.html" target="_blank" rel="noopener">OOAD利器之UML基础</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在写有关设计模式的Blog，但涉及到UML类图这方面的话，总是从网上下载现成的图片，这也导致了我对UML类图这一方面，并没有一个很深的印象，所以决定写这么一篇文章，加深一下自己对UML类图的印象。&lt;/p&gt;
&lt;h1 id=&quot;为什么需要UML图&quot;&gt;&lt;a href=&quot;#为什么
      
    
    </summary>
    
      <category term="UML" scheme="http://nastublog.com/categories/UML/"/>
    
    
      <category term="UML" scheme="http://nastublog.com/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>面试总结-招银网络科技</title>
    <link href="http://nastublog.com/2018/07/23/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-%E6%8B%9B%E9%93%B6%E7%BD%91%E7%BB%9C%E7%A7%91%E6%8A%80/"/>
    <id>http://nastublog.com/2018/07/23/面试总结-招银网络科技/</id>
    <published>2018-07-23T15:27:41.000Z</published>
    <updated>2018-07-23T16:12:20.572Z</updated>
    
    <content type="html"><![CDATA[<p>今天去杭州招银笔面试回来，真的是累的不行，天气又热，人生地不熟的，上午百世的面试还被面试官”愉快的”放了鸽子，真的是祸不单行。<br>    下午早早地到了面试地点，发现超多招银的人在排队，我开始还以为有啥活动，或者是领取什么物品，结果一问，全是在排队等电梯，我的天，和游乐场有的一拼。<br>    在面试地点，见到一个年轻的小哥哥，问了一下，竟然已经做IOS做了三年了，而且实际工作年龄还不止三年，真的是人不可貌相呢。小哥哥人真好，我笔不知道丢哪去了，他还送了支笔给我，希望这么好的人能够面试通过啦。<br>    招银科技笔试和第一次面试是穿插进行的，笔试简直是一塌糊涂，很多概念性的问题和看过的问题都已经忘了，一共30道单选题，60道填空题和4道大题，大概记一下大题吧，算是给自己长点记性，留个纪念。<br>    第一题，就是最大公约数和最小公倍数的填空实现，没啥难度，毕竟大学做了1年的ACM。<br>    第二题，问了一下Java IO类设计采用了什么模式，也就是装饰器模式，然后简单介绍了一下，我就拿奶茶店的例子介绍了一下，然后让画UML类图，这就很尴尬啦，我的博客还没写到装饰器模式，之前也只是粗略的看了一下，并没有准确的记住，看样子UML图还要加强。<br>    第三题，一道简单的SQL题，千不该万不该，这道题竟然出了岔子，最后一个取最大值的问题，我竟然把max函数写在了where里面，看样子，真的离了编辑器写代码都是错啊，引以为戒引以为戒，顺带一提，填空里的synchronized我竟然都拼错了，ide的自动补全功能真的是惯坏了我哦。<br>    第四题，用你的思路实现队列。并用伪代码描述，哈哈哈，我就知道队列的存储结构是用数组实现的，具体实现思路嘛，就凭空乱想。因为队列是一个先进先出的结构，所以我就大概说了想法就是永远只取数组的最后一个数。大概就是定义了一个静态变量，用于表述当前的队列里的元素个数，然后定义了一个数组用于存储插入进来的元素。然后判断了一下如果当前元素个数是0，就会抛出异常，写的是伪代码，但是写的十分杂乱，现在想起来，的确是有挺多问题的。改天可以写一篇博客，专门描述一下栈和队列的实现方法。<br>    面试的话，穿插在笔试中间进行的，上来也就大概自我介绍了一下，然后面试官让我介绍一下自己在项目中做过了什么，什么是最重要的最有价值的，我大概就说了一下中交租赁系统里面的工作流模块，和我基于原生的activiti引擎如何二开新功能的，因为本身一面试就紧张，结结巴巴的，面试官十分和善，让我别紧张，项目说的中规中矩吧，感觉没有把自己的突出点突出出来，还是要针对自己的项目多一下。<br>    然后就问了一下Java基础，很丢脸，上来第一题我就被问住了，问了我Java引用的类型，我一开始还以为是强弱引用，可是强弱引用的概念在我脑子里十分模糊，所以我没会打上来，这个还是挺让人难受的，引以为戒吧，其实Java的引用类型就是分为值类型和引用类型，值类型就是Java的8大基本类型，而引用类型,是指除了基本的变量类型之外的所有类型。<br>    然后闻了一下JVM类加载的过程，我大概就把之前在博客和公众号看到的过程说了一下，类加载的7个过程，加载-验证-准备-解析-初始化-使用-卸载，说的马马虎虎吧，面试官也没深入去问，JVM在面试中还是会被经常问到的，需要继续加强吧。<br>    然后问了一下设计模式，正好我最近在看这一类的书，比较Lucky，让我说了两种设计模式，我说了单例和代理，然后让我分别对两种设计模式进行了介绍，我就说了一下单例模式的几种实现方法：懒汉、饿汉、加锁的懒汉、双重检查和枚举，在这里面试官问我为什么采取双重检查的机制，我回答不采取这个依旧会产生线程不安全的问题，面试官问了双重检查就能避免这个问题么，我说是的，他说最好回去再看一下，然后我看了一下，双重检查依旧会有线程不安全的问题存在，原因是因为指令重排，后续也需要在巩固一下，然后又说了代理模式，也就简单的提了一下静态代理和动态代理的两种实现方法，基于JDK和InvacationHandler接口和Proxy实现的动态代理和cglib的动态代理，然后让画了UML图，结果忘了画出Proxy也是实现Subject接口的，明明刚刚才看过，实在不应该啊。<br>    最后问了fail-fast和fail-safe机制，这个实在是没有了解过了，看了一下，貌似是和集合并发有关的，回来之后要多看看。<br>面的，这次跳槽估计是一次漫长的旅程，也希望找到心仪的工作吧。<br>    总结一下吧，明显这次笔试面试准备的不够充分，这也是因为工作一年来，前半年都没想着要好好看书，等到真正要找工作了，才发现自己的基础十分薄弱，这次面试也算给了自己一个教训吧，真的是要下点功夫好好看书了。不过得到了喜欢的女孩子的鼓励，还算是比较开心的，为了不辜负她的期待，努力吧，少年。<br>        针对这次面试，之后也会专门总结一点有关笔面试看到的题目，大致上也就是Oracle数据库方面、Java基础方</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天去杭州招银笔面试回来，真的是累的不行，天气又热，人生地不熟的，上午百世的面试还被面试官”愉快的”放了鸽子，真的是祸不单行。&lt;br&gt;    下午早早地到了面试地点，发现超多招银的人在排队，我开始还以为有啥活动，或者是领取什么物品，结果一问，全是在排队等电梯，我的天，和游乐
      
    
    </summary>
    
      <category term="面试" scheme="http://nastublog.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="随笔" scheme="http://nastublog.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-代理模式(Proxy)</title>
    <link href="http://nastublog.com/2018/07/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-Proxy/"/>
    <id>http://nastublog.com/2018/07/21/设计模式-代理模式-Proxy/</id>
    <published>2018-07-21T05:56:58.000Z</published>
    <updated>2018-07-31T15:41:32.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近在准备跳槽的面试，然后在看Spring框架原理的时候，顺便了解一下AOP的设计模式-代理模式。<br><br>其实，代理模式在我们生活中非常常见，比如，玩游戏的时候不想手动练级，于是我们会去网上找代练帮我们完成练级的过程，这就是代理。再比如打官司的时候请律师，这也是代理，这样子我们只用准备我们的证词发言，而对于那些事件的调查和分析我们都全权交给了律师来做。</p><h1 id="代理模式的定义"><a href="#代理模式的定义" class="headerlink" title="代理模式的定义"></a>代理模式的定义</h1><p>代理模式也被叫做委托模式，是一个日常使用率很高的模式，其定义如下：<br>为其他对象提供一种代理控制这个对象的访问。</p><p>代理模式的UML图如下:</p><p><img src="/2018/07/21/设计模式-代理模式-Proxy/代理模式.png" alt="代理模式"></p><p>一般的代理模式有着三个角色，下面对这三个角色进行一个简单的介绍:<br><br>1.Subject 抽象主题角色<br>它可以是抽象类也可以是接口，是一个最普通的业务定义类型，比如在玩游戏这个例子中，它代表着游戏玩家这一群体。</p><p>2.RealSubject 具体主题角色<br>它其实就是被代理的角色，它继承或者实现了抽象主题角色，比如我请了一个工作室帮我代练，那么我的游戏角色<br>就是这个被代理的角色。</p><p>3.Proxy 代理主题角色<br>也叫做委托类、代理类。它负责处理对真实角色的应用，内部含有了RealSubject的引用，然后调用了具体角色里对抽象角色的实现方法，并且可以在加入自己的逻辑，实现一些预处理和善后工作。在玩游戏的这个例子里，对应的就是游戏代练工作室。</p><p>这就是代理模式的三个具体类。</p><h1 id="代理模式的应用"><a href="#代理模式的应用" class="headerlink" title="代理模式的应用"></a>代理模式的应用</h1><h2 id="代理模式的主要作用"><a href="#代理模式的主要作用" class="headerlink" title="代理模式的主要作用"></a>代理模式的主要作用</h2><p>通过引入代理对象来间接地去访问目标对象。</p><h2 id="代理模式的优点"><a href="#代理模式的优点" class="headerlink" title="代理模式的优点"></a>代理模式的优点</h2><p>1.划分了具体的职责<br>RealSubject只需要实现具体的业务逻辑，不需要对其他的逻辑进行操作，这些操作全权交给代理类去实现，后期可以通过代理类的预处理和善后处理的方法完成一件事务。<br>2.高扩展性<br>业务逻辑随时随地都会发生变化，但是，无论其怎么变化，代理类都不需要进行修改。<br>3.智能化<br>具体体现在动态代理上，之后会提到。</p><h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><p>防止直接访问目标目标对象给系统带来的不必要的复杂性。</p><h1 id="代理模式的具体实现"><a href="#代理模式的具体实现" class="headerlink" title="代理模式的具体实现"></a>代理模式的具体实现</h1><p>这里借用了玩游戏的例子，来看一下最简单的代理模式的实现：</p><p>先定义一个抽象的玩家接口，也就是上面上的Subject角色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package Proxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 玩家接口</span><br><span class="line"></span><br><span class="line"> * @Date: Created in 00:11 2018/7/20</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public interface IGamePlayer &#123;</span><br><span class="line"></span><br><span class="line">    public void login(String user, String password);</span><br><span class="line"></span><br><span class="line">    public void killBoss();</span><br><span class="line"></span><br><span class="line">    public void upgrade();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是具体玩家实现类，也就是RealSubject角色:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package Proxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Date: Created in 23:15 2018/7/20</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class GamePlayer implements IGamePlayer &#123;</span><br><span class="line"></span><br><span class="line">    private String name = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    public GamePlayer(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void login(String user, String password) &#123;</span><br><span class="line">        System.out.println(&quot;登录名为&quot; + user + &quot;的用户&quot; + this.name + &quot;登陆了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void killBoss() &#123;</span><br><span class="line">        System.out.println(&quot;用户&quot; + this.name + &quot;在打怪&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void upgrade() &#123;</span><br><span class="line">        System.out.println(&quot;用户&quot; + this.name + &quot;升级了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来我们的代练出场了，就是本章最重要的Proxy角色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package Proxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 静态代理实现（代理类的好处可以实现预处理和善后处理）</span><br><span class="line"> * @Date: Created in 23:19 2018/7/20</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class GamePlayerProxy implements IGamePlayer &#123;</span><br><span class="line"></span><br><span class="line">    private IGamePlayer gamePlayer = null;</span><br><span class="line"></span><br><span class="line">    public GamePlayerProxy(IGamePlayer gamePlayer) &#123;</span><br><span class="line">        this.gamePlayer = gamePlayer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void login(String user, String password) &#123;</span><br><span class="line">        this.doSomethingBefore();</span><br><span class="line">        this.gamePlayer.login(user, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void killBoss() &#123;</span><br><span class="line">        this.gamePlayer.killBoss();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void upgrade() &#123;</span><br><span class="line">        this.gamePlayer.upgrade();</span><br><span class="line">        this.doSomethingAfter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void doSomethingBefore() &#123;</span><br><span class="line">        System.out.println(&quot;代练开始&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void doSomethingAfter() &#123;</span><br><span class="line">        System.out.println(&quot;代练结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来我们写一个测试类来测试一下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package Proxy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 测试类</span><br><span class="line"> * @Date: Created in 23:21 2018/7/20</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        // 定义一个玩家</span><br><span class="line"></span><br><span class="line">        IGamePlayer gamePlayer = new GamePlayer(&quot;初夏倾城&quot;);</span><br><span class="line"></span><br><span class="line">        // 静态代理</span><br><span class="line">        // 定义一个代理类</span><br><span class="line">        IGamePlayer proxy = new GamePlayerProxy(gamePlayer);</span><br><span class="line"></span><br><span class="line">        proxy.login(&quot;natsu&quot;, &quot;123&quot;);</span><br><span class="line"></span><br><span class="line">        proxy.killBoss();</span><br><span class="line"></span><br><span class="line">        proxy.upgrade();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面就是我们具体的输出结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">代练开始</span><br><span class="line">登录名为natsu的用户初夏倾城登陆了</span><br><span class="line">代练结束</span><br><span class="line">用户初夏倾城在打怪</span><br><span class="line">用户初夏倾城升级了</span><br><span class="line">代练结束</span><br></pre></td></tr></table></figure></p><p>这就是一个简单的代理模式的实现。</p><h1 id="代理模式的扩展"><a href="#代理模式的扩展" class="headerlink" title="代理模式的扩展"></a>代理模式的扩展</h1><p>代理模式也分为多种，大致上可以分为静态代理和动态代理，静态代理又可以划分为普通代理和强制代理，我们先来介绍一下普通代理和强制代理，动态代理是个大Boss，我们放在最后再说，现在我们来简单介绍一下普通代理和强制代理。</p><h2 id="普通代理"><a href="#普通代理" class="headerlink" title="普通代理"></a>普通代理</h2><p>普通代理，就是要求客户端只能访问代理角色，而不能访问真实角色。我们该怎么实现呢。</p><h2 id="强制代理"><a href="#强制代理" class="headerlink" title="强制代理"></a>强制代理</h2><p>一般代理都是通过代理找到真是角色，但是强制代理确实强制的，就是你必须通过真实角色找到代理角色。<br>很典型的一个例子，我们要找一个明显拍广告，于是直接拨通了这个明星的电话，但是他却必须要求你去找他的经纪人，本来你想绕过经纪人，结果返回的还是他的经纪人，这里经纪人就是代理。就是说，你可以不必知道代理的存在，但是你所有的所作所为还是代理提供的。</p><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><h2 id="静态代理和动态代理的区别"><a href="#静态代理和动态代理的区别" class="headerlink" title="静态代理和动态代理的区别"></a>静态代理和动态代理的区别</h2><p>最重要的当然要放到最后来说，之前我们所有的代码实现都是静态代理，那么静态代理和动态代理又有什么区别呢？<br>静态代理是由程序员创建或特定工具自动生成源码，也就是说，在编译时就已经将接口、被代理类、代理类确定下来。也就是说，在程序运行之前，代理类的.class文件就已经生成。<br>静态代理有一个坏处，因为每一个代理类都需要自己去实现，所以就会造成程序中的代理类越来越多，那有什么解决方法呢，这时候就要用到动态代理。<br>动态代理的意思就是在实现阶段我们并不需要关心去代理谁，而是在运行阶段才能确定是代理哪一个对象。</p><h2 id="动态代理的简单实现"><a href="#动态代理的简单实现" class="headerlink" title="动态代理的简单实现"></a>动态代理的简单实现</h2><p>动态代理现在有两种的实现方法，一种是JDK动态代理，一种是CGLIB动态代理。<br>这两个的区别是，JDK动态代理只能对实现了接口的类生成代理，而并不能只单单针对类。<br>而CGLIB则是针对类实现代理，主要是对指定的类生成子类，覆盖其中的方法。<br>有关JDK和CGLIB实现动态代理的区别，我会单独写一篇博客记录一下，这篇博客，主要实现方法就是JDK的动态代理。<br>动态代理的主要实现需要JDK提供的动态代理接口InvocationHandler和Proxy类。<br>举个例子吧，就拿卖水果来说，以前都是水果商自己出来摆摊或者开店，但随着电商的越来越发达，很多水果商都选择将自己销售交给电商去代理，我们就用动态代理来实现一下这个例子。</p><p>先定义一个商家的接口,它有着一个销售商品的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package Proxy.DynamicProxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 商家接口</span><br><span class="line"> * @Date: Created in 11:30 2018/7/22</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public interface ISeller &#123;</span><br><span class="line"></span><br><span class="line">    void sell(String goods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后定义一个水果卖家，它有着一个私有属性sellerName，用来存储卖家名字，然后实现了ISeller的sell方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package Proxy.DynamicProxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 水果售卖商</span><br><span class="line"> * @Date: Created in 11:45 2018/7/22</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class FruitSeller implements ISeller  &#123;</span><br><span class="line"></span><br><span class="line">    String sellerName;</span><br><span class="line"></span><br><span class="line">    public FruitSeller(String sellerName) &#123;</span><br><span class="line">        this.sellerName = sellerName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sell(String goods) &#123;</span><br><span class="line">        System.out.println(this.sellerName+&quot;卖&quot;+goods);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后定义一个动态代理类TaobaoProxy，他实现了Java提供的InvocationHandler接口，这个类中持有一个被代理对象的实例target。InvocationHandler中有一个invoke方法，所有执行代理对象的方法都会被替换成执行invoke方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package Proxy.DynamicProxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 淘宝代理销售</span><br><span class="line"> * @Date: Created in 11:46 2018/7/22</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class TaobaoProxy implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    private Object targetObject;</span><br><span class="line"></span><br><span class="line">    public TaobaoProxy(Object targetObject) &#123;</span><br><span class="line">        this.targetObject = targetObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        Object result = method.invoke(targetObject, args);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们写一个场景类来测试一下，场景类里调用了Proxy的newProxyInstance方法动态的生成了一个代理者。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package Proxy.DynamicProxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 实现场景类</span><br><span class="line"> * @Date: Created in 11:50 2018/7/22</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ISeller fruitSeller = new FruitSeller(&quot;天天果园&quot;);</span><br><span class="line"></span><br><span class="line">        // 定义一个handler</span><br><span class="line">        InvocationHandler handler = new TaobaoProxy(fruitSeller);</span><br><span class="line"></span><br><span class="line">        ISeller proxy = (ISeller) Proxy.newProxyInstance(fruitSeller.getClass().getClassLoader(), fruitSeller.getClass().getInterfaces(), handler);</span><br><span class="line"></span><br><span class="line">        proxy.sell(&quot;西瓜&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行以上代码，得到结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">天天果园卖西瓜</span><br></pre></td></tr></table></figure></p><p>这就是动态代理的简单实现了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>代理模式运用的十分广泛，往大了说一个系统框架、企业平台，往小了说，事务处理，这些地方都可能会用到代理模式。<br>Spring的AOP就是基于代理模式实现的。<br>在调试代码时，经常会看到$Proxy这样的结构，这就是一个动态代理了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.importnew.com/26116.html" target="_blank" rel="noopener">说说 JAVA 代理模式</a><br><a href="https://blog.csdn.net/carson_ho/article/details/54910472" target="_blank" rel="noopener">代理模式（Proxy Pattern）- 最易懂的设计模式解析</a><br><a href="https://www.cnblogs.com/gonjan-blog/p/6685611.html" target="_blank" rel="noopener">java动态代理实现与原理详细分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;最近在准备跳槽的面试，然后在看Spring框架原理的时候，顺便了解一下AOP的设计模式-代理模式。&lt;br&gt;&lt;br&gt;其实，代理模式在我们生活中
      
    
    </summary>
    
      <category term="设计模式" scheme="http://nastublog.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://nastublog.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-建造者模式(Builder)</title>
    <link href="http://nastublog.com/2018/07/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-Builder/"/>
    <id>http://nastublog.com/2018/07/16/设计模式-建造者模式-Builder/</id>
    <published>2018-07-16T14:49:59.000Z</published>
    <updated>2018-07-24T15:43:32.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>之前在看《Effective Java》的时候，说到对象属性比较复杂的时候考虑使用构建器构造对象，加上StringBuilder类源码的阅读，让我对建造者模式有了一定的了解，乘着刚看完《设计模式之禅》有关于建造者模式的章节，以及阅读了几位大佬的博客，写了这篇文章。</p><h1 id="建造者模式的定义"><a href="#建造者模式的定义" class="headerlink" title="建造者模式的定义"></a>建造者模式的定义</h1><p>建造者模式（Builder Pattern）的定义如下:<br><br>将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。</p><p>建造者模式具体的UML类图如下:<br><img src="/2018/07/16/设计模式-建造者模式-Builder/builder.jpg" alt="建造者模式"></p><p>在建造者模式中，有如下四个角色，在这里，我们用一个土豪定制自己的跑车的实例，分别对着四个角色进行描述:<br><br>1.Product 产品类<br>代表着具体的产品，比如，土豪的跑车，跑车有着轮胎、引擎，车身等等多重属性，一般产品类还可以联合模板方法模式，也就是说有模板方法和基本方法，这个具体可以参考模板模式，之后会写一篇专门介绍。</p><p>2.Builder 抽象建造者<br>用来规范产品的组建，而一般产品的组建是由其子类实现。在这个例子，我们可以理解为所有提供组装跑车的工厂。</p><p>3.ConcreteBuilder 具体建造者<br>实现抽象建造者定义的所有方法，并且返回一个已经组装好的对象。比如，我们这个土豪想定制一台劳斯莱斯的跑车，就需要一个专门定制劳斯莱斯跑车的工厂。</p><p>4.Director 导演类<br>负责安排已有建造顺序，并且找到对应的具体建造者。我们土豪肯定不会大费周折的去找一个劳斯莱斯的跑车工厂，所以，他会去找一个专门提供跑车定制的门店，由这个门店联系工厂，告诉工厂土豪需要什么样的跑车。</p><p>这大概就是建造者模式用到的4个类。</p><h1 id="建造者模式的具体实现"><a href="#建造者模式的具体实现" class="headerlink" title="建造者模式的具体实现"></a>建造者模式的具体实现</h1><p>既然上面我们举了这样一个例子，下面我们就来实现它吧。</p><p>先定一个跑车的产品类，有着品牌(name)、轮胎(wheel)、车身(skeleton)、引擎(enigine)四个属性，为了满足土豪装逼的心理，我们加了一个展示方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package Builder;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 跑车-产品类</span><br><span class="line"> * @Date: Created in 22:16 2018/7/16</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class Car &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private String wheel;</span><br><span class="line"></span><br><span class="line">    private String skeleton;</span><br><span class="line"></span><br><span class="line">    private String engine;</span><br><span class="line"></span><br><span class="line">    public String getWheel() &#123;</span><br><span class="line">        return wheel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setWheel(String wheel) &#123;</span><br><span class="line">        this.wheel = wheel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSkeleton() &#123;</span><br><span class="line">        return skeleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSkeleton(String skeleton) &#123;</span><br><span class="line">        this.skeleton = skeleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getEngine() &#123;</span><br><span class="line">        return engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setEngine(String engine) &#123;</span><br><span class="line">        this.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showCar()&#123;</span><br><span class="line">        System.out.println(&quot;品牌是：&quot; + name);</span><br><span class="line">        System.out.println(&quot;轮胎是：&quot; + wheel);</span><br><span class="line">        System.out.println(&quot;车身是：&quot; + skeleton);</span><br><span class="line">        System.out.println(&quot;发动机是: &quot; + engine);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><p>再来就是我们抽象的建造类，代表着所有能定制跑车的这一类工厂。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package Builder;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 抽象汽车建造方法</span><br><span class="line"> * @Date: Created in 22:14 2018/7/16</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public abstract class ICarBuilder &#123;</span><br><span class="line"></span><br><span class="line">    public abstract void buildWheel();</span><br><span class="line"></span><br><span class="line">    public abstract void buildSkeleton();</span><br><span class="line"></span><br><span class="line">    public abstract void buildEngine();</span><br><span class="line"></span><br><span class="line">    public abstract void buliderName();</span><br><span class="line"></span><br><span class="line">    public abstract Car buildCar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是我们具体的建造类，也就是劳斯莱斯的定制工厂啦。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package Builder;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 具体汽车实现类(组装人员)</span><br><span class="line"> * @Date: Created in 22:17 2018/7/16</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class ConcreteBuilder extends ICarBuilder &#123;</span><br><span class="line"></span><br><span class="line">    private Car car = new Car();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buildWheel() &#123;</span><br><span class="line">        car.setWheel(&quot;米其林轮胎&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buildSkeleton() &#123;</span><br><span class="line">        car.setSkeleton(&quot;流线型车声&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buildEngine() &#123;</span><br><span class="line">        car.setEngine(&quot;涡轮发动机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buliderName() &#123;</span><br><span class="line">        car.setName(&quot;劳斯莱斯&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Car buildCar() &#123;</span><br><span class="line">        return this.car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是我们和土豪直接沟通的定制车店的老板来，是由他去联系定制车的工厂的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package Builder;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 导演类-定制车店的老板</span><br><span class="line"> * @Date: Created in 22:20 2018/7/16</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class Director &#123;</span><br><span class="line">    public Car Construct(ICarBuilder iCarBuilder) &#123;</span><br><span class="line">        iCarBuilder.buildWheel();</span><br><span class="line">        iCarBuilder.buildSkeleton();</span><br><span class="line">        iCarBuilder.buildEngine();</span><br><span class="line">        iCarBuilder.buliderName();</span><br><span class="line">        return iCarBuilder.buildCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后写个测试类测试一下土豪买车的过程:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package Builder;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Date: Created in 22:21 2018/7/16</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class MainTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;我要去买车了&quot;);</span><br><span class="line">        Director director = new Director();</span><br><span class="line">        System.out.println(&quot;老板来一辆车&quot;);</span><br><span class="line">        System.out.println(&quot;找到组装工厂&quot;);</span><br><span class="line">        ICarBuilder carBuilder = new ConcreteBuilder();</span><br><span class="line">        Car myCar  = director.Construct(carBuilder);</span><br><span class="line">        System.out.println(&quot;车组装好了：&quot;);</span><br><span class="line">        System.out.println(&quot;看看我的新车吧：&quot;);</span><br><span class="line">        myCar.showCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是我们程序的输出结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">我要去买车了</span><br><span class="line">老板来一辆车</span><br><span class="line">找到组装工厂</span><br><span class="line">车组装好了：</span><br><span class="line">看看我的新车吧：</span><br><span class="line">品牌是：劳斯莱斯</span><br><span class="line">轮胎是：米其林轮胎</span><br><span class="line">车身是：流线型车声</span><br><span class="line">发动机是: 涡轮发动机</span><br></pre></td></tr></table></figure></p><p>好了，至此，我们土豪买车的过程到此结束。</p><h1 id="建造者模式的应用"><a href="#建造者模式的应用" class="headerlink" title="建造者模式的应用"></a>建造者模式的应用</h1><h2 id="建造者模式的优点"><a href="#建造者模式的优点" class="headerlink" title="建造者模式的优点"></a>建造者模式的优点</h2><p>1.封装性<br>使用建造者模式，可以让客户端不必知道产品内部的组成细节。<br>2.易于扩展<br>具体建造者ConcreteBuilder之间是相互独立的，易于扩展。<br>3.便于控制细节风险<br>由于具体的建造者式独立的，因此可以对建造的过程逐步细化，而不会对其他的模块产生影响。</p><h2 id="建造者模式的缺点"><a href="#建造者模式的缺点" class="headerlink" title="建造者模式的缺点"></a>建造者模式的缺点</h2><p>1.如果产品内部变化十分复杂的话，就会需要定义许多具体的建造者来满足这些变化，这样会让系统变得十分庞大。<br>2，适用范围有限，一般要求所创建的产品具有较多的共同点。</p><h2 id="建造者模式的使用场景"><a href="#建造者模式的使用场景" class="headerlink" title="建造者模式的使用场景"></a>建造者模式的使用场景</h2><p>1.相同的方法，不同的执行顺序，产生不同的事件结果时，就可以采用建造者模式。<br>2.需要生成的产品内部结构复杂，但是这些产品之间又具有一定的共性；<br>总之，就是在需要隔离复杂对象的创建，并且这些对象之间有相同的共性，而且不同的创建顺序会得到不同的结果的时候，就可以用到建造者模式了。</p><h1 id="建造者模式的总结"><a href="#建造者模式的总结" class="headerlink" title="建造者模式的总结"></a>建造者模式的总结</h1><p>建造者模式虽然和工厂模式同为创建型的设计模式，但本质上存在着的一定的区别，建造者模式关注的时装配的顺序，也就是说基本的方法已经实现，只是方法执行顺序不同产生的结果不同。而工厂方法的重点则是创建，创建零件是其主要职责，而装配的顺序并不是其所关心的。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/lmb55/article/details/50990732" target="_blank" rel="noopener">大话设计模式—建造者模式</a><br><a href="https://blog.csdn.net/carson_ho/article/details/54910597" target="_blank" rel="noopener">建造者模式（Builder Pattern）- 最易懂的设计模式解析</a><br><a href="https://blog.csdn.net/u013256816/article/details/50978024" target="_blank" rel="noopener">设计模式：建造者模式（Builder）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;之前在看《Effective Java》的时候，说到对象属性比较复杂的时候考虑使用构建器构造对象，加上StringBuilder类源码的阅读
      
    
    </summary>
    
      <category term="Java学习" scheme="http://nastublog.com/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="设计模式" scheme="http://nastublog.com/categories/Java%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://nastublog.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-六大原则(SOLID)</title>
    <link href="http://nastublog.com/2018/07/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>http://nastublog.com/2018/07/09/设计模式-六大原则/</id>
    <published>2018-07-09T15:23:35.000Z</published>
    <updated>2018-07-15T04:36:21.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近在看《设计模式之禅》这本书，看完了前六章的6大原则后，结合自己所写过的代码，感触颇深，于是随笔写一下这6大原则的主要内容，部分内容参考了该书里的内容，算是做个借鉴了。<br><br>软件设计中，最大的难题就是应对需求的变化，但是，在实际工作中，需求的变化是必然存在的，而且也是不可预料的。所以，我们要为这些不可预料的需求变化事先做好准备，这是一件十分痛苦的事情，不过还好，我们已经站在了巨人的肩膀上。软件设计的大师给我们提供了非常好的6大设计原则和23个设计模式来应对这些变化。</p><h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><p>1.SRP(Single Responsibility Principle)单一职责原则<br>2.OCP(Open Closed Principle)开闭原则<br>3.LSP(Liskov Substitution Principle)里式替换原则<br>4.Law of Demeter 迪米特法则<br>5.ISP(Interface Segregation Principle)接口隔离原则<br>6.DIP(Dependence Inversion Principle)依赖倒置原则<br>把这六个原则的首字母联合起来，就是SOLID(L重复只取一个)，意思是稳定的，这六大原则使用的意义也就是建立出稳定、灵活、健壮的设计用来面对不可预知的需求变更。<br>下面我根据自己看书的理解，结合平常自己写代码的思考,稍微总结一下6大设计原则的基本内容。</p><h1 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h1><p>单一职责原则的定义是:一个类应该有且只有一个原因会引起类的变更。换句话就是说，一个类应该只有有一个职责。<br><br>我在当前项目，也就是中交租赁中发现，很多接口里面都会有很多方法，查询，更新，计算等等多种多样的方法聚集在一个接口里，导致这个接口的实现类代码非常复杂，光是阅读代码就会有很大的阻碍，当客户在这个模块遇到多个Bug的时候，可能会造成，好几个开发人员同时修改这一个类的方法，不免的会产生各种各样的冲突，甚至会导致其中一个开发人员修改的方法对另一个开发人员正在修复的问题产生影响，维护难度呈现几何式的倍增，所以，从中可以看出单一职责原则的重要性。<br><br>单一职责原则的好处主要是:<br><br>1、类的复杂程度降低，可读性提高,可维护性提高，实现了什么职责都有明确的定义，一目了然，维护起来也更加方便;<br><br>2、后期变更引起的风险也降低。<br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;最近在看《设计模式之禅》这本书，看完了前六章的6大原则后，结合自己所写过的代码，感触颇深，于是随笔写一下这6大原则的主要内容，部分内容参考了
      
    
    </summary>
    
      <category term="Java学习" scheme="http://nastublog.com/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="设计模式" scheme="http://nastublog.com/categories/Java%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式-单例模式(Singleton)</title>
    <link href="http://nastublog.com/2018/06/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-Singleton/"/>
    <id>http://nastublog.com/2018/06/30/设计模式-单例模式-Singleton/</id>
    <published>2018-06-29T17:19:38.000Z</published>
    <updated>2018-07-29T13:48:07.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>这里举个例子，古代的时候，一般只会有一个皇帝，比如秦朝。可以这样理解，皇帝是一个类，秦始皇则是一个对象实例。只会有一个皇帝实例，不然就乱套了，这在代码设计的思想中，就被称之为单例模式（Singleton Pattern）。</p><h1 id="单例模式的定义和使用场景"><a href="#单例模式的定义和使用场景" class="headerlink" title="单例模式的定义和使用场景"></a>单例模式的定义和使用场景</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>单例模式，定义如下:<br><br>确保某一个类只有一个实例，并且自行实例化并向整个系统提供这个实例。</p><h2 id="单例模式的使用场景"><a href="#单例模式的使用场景" class="headerlink" title="单例模式的使用场景"></a>单例模式的使用场景</h2><p>在一个系统中，要求一个类有且仅能有一个对象，如果出现多个对象就会出现一系列不可预知的错误，就可以采用单例模式了，具体如下:</p><p>1.定义了大量静态常量和静态方法的工具类;<br><br>2.需要生成唯一序列的环境;<br><br>3.需要频繁创建然后销毁的实例;<br><br>4.频繁访问数据库或文件的对象。<br></p><p>具体的应用场景:<br><br>1.网站的计数器，如果不是单例的话就无法实现同步;<br><br>2.Windows的任务管理器（无法打开两个任务管理器）;<br><br>3.Web应用的配置对象的读取;<br><br>4.数据库连接池;<br><br>5.Web应用配置文件的读取。<br></p><h1 id="单例模式的要素"><a href="#单例模式的要素" class="headerlink" title="单例模式的要素"></a>单例模式的要素</h1><p>如果想让一个类只拥有一个实例对象，很简单：<br><br>1.私有的构造方法，禁止外部访问;<br><br>2.私有静态引用指向实例;<br><br>3.将自己实例当做返回值的静态共有方法。<br></p><h1 id="单例模式的具体实现"><a href="#单例模式的具体实现" class="headerlink" title="单例模式的具体实现"></a>单例模式的具体实现</h1><p>单例模式,在我们平常使用中，主要有两种实现方法:饿汉式、懒汉式。</p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>何为饿汉式，饿汉，饥不择食，此处同义：在加载类的时候就会创建类的单例，并保存在类中。</p><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SingleTon &#123;</span><br><span class="line">    private static SingleTon instance = new SingleTon();</span><br><span class="line">    private SingleTon() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static SingleTon getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void say() &#123;</span><br><span class="line">        System.out.println(&quot;我是皇帝秦始皇&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为实例对象由static修饰，所以在类加载的时候就会调用私有的构造方法，创建类的单例，保存在类中。</p><p>这样做，优点是:<br><br>1.借由JVM实现了线程安全;<br><br>2.因为在类加载时就创建了类的单例，调用速度会比较快。<br></p><p>缺点也很明显，因为类加载就会创建该类的单例，不管用户是否需要，可能我们永远不会用到getInstance方法，但执行该类的其他静态方法或者加载了该类（class.forName)，那么这个实例仍然初始化，这样做会占用大量的内存资源。</p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>何为懒，就是延时，特点就是单例在类第一次被使用的时候才会构建，延时初始化。</p><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class SingleTon &#123;</span><br><span class="line">    private static SingleTon instance = null;</span><br><span class="line">    private SingleTon() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static SingleTon getInstance() &#123;</span><br><span class="line">          if (instance == null) &#123;</span><br><span class="line">              //多个线程判断instance都为null时，在执行new操作时多线程会出现重复情况</span><br><span class="line">                        instance = new SingleTon();</span><br><span class="line">                &#125;</span><br><span class="line">                return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void say() &#123;</span><br><span class="line">        System.out.println(&quot;我是皇帝秦始皇&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法相较于饿汉式的优点就是资源利用效率高，在不执行类的静态方法getInstance的时候，类的实例就不会被创建。<br>该方法的缺点在于，当系统压力增大，并发量增加的时候就可能会出现多个实例，当线程A执行到instance = new SingleTon()的时候，对象的创建是需要时间的，此时线程B执行到了if(instance == null)，判断条件也为真，于是继续执行下去，线程A获得了一个对象，线程B也获得了一个对象，在内存中就出现了两个对象。<br></p><h1 id="单例模式的额外扩展"><a href="#单例模式的额外扩展" class="headerlink" title="单例模式的额外扩展"></a>单例模式的额外扩展</h1><p>解决线程不安全的问题，可以对方法进行同步加锁，对getInstance()进行同步，代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton instance;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样做也有缺点，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。</p><p>也可以采用同步代码块的方式，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton instance;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                instance = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。</p><p>为了解决这个问题，可以采取双重加锁，就是在同步代码块内部在进行一次判断，杜绝这个问题的产生：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton instance;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">             if (singleton == null) &#123;</span><br><span class="line">                    singleton = new Singleton();</span><br><span class="line">                &#125;            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法在多线程的开发中被称之为Double-Check双重检查，这样实现单例模式的方法，不仅具备了懒汉式延时加载，资源占用较少的有点，也避免了线程不安全以及同步方法效率低的缺点，是比较推荐的方式。</p><p>单例模式还有其他的实现方式，比如静态内部类、枚举等，单都不如上面常见，在此不一一列举，如有兴趣，可以参考以下Blog:<br><br><a href="https://www.cnblogs.com/zhaoyan001/p/6365064.html" target="_blank" rel="noopener">单例模式的八种写法比较</a></p><h1 id="多例模式"><a href="#多例模式" class="headerlink" title="多例模式"></a>多例模式</h1><p>一个类想要有多个对象，很简单，new关键字就可以实现，一个类如果想只有一个对象，则可以使用单例模式，但是一个类如果想产生指定个数的对象，又该如何实现呢？<br><br>这里提供一个思路，在类里定义一个静态int变量，用来表明最多能产生的实例数量，然后定义一个List用来存放产生的对象，然后在类的静态代码块里写生成对象的逻辑，这样就可以实现一个类产生指定个数的对象。(同样，这是在类加载的时候就产生实例的)<br><br>这里举一个皇帝类作为代码的时候，具体可参照《设计模式之禅》第七章《单例模式》。</p><p>代码实现如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class Emperor &#123;</span><br><span class="line">    private static int maxEmperorNum = 2;</span><br><span class="line"></span><br><span class="line">    private static int numOfEmperorNum = 0;</span><br><span class="line"></span><br><span class="line">    private static List&lt;Emperor&gt; emperorList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private static List&lt;String&gt; emperorNameList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        for (int i = 0; i &lt; maxEmperorNum; i++) &#123;</span><br><span class="line">            emperorList.add(new Emperor(&quot;皇&quot; + （i+1） + &quot;帝&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Emperor() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Emperor(String emperorName) &#123;</span><br><span class="line">        emperorNameList.add(emperorName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 随机取得一个皇帝</span><br><span class="line">    public static Emperor getInstance() &#123;</span><br><span class="line">        Random random = new Random();</span><br><span class="line">        int numOfEmperorNum = random.nextInt(maxEmperorNum);</span><br><span class="line">        return emperorList.get(numOfEmperorNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void say() &#123;</span><br><span class="line">        System.out.println(emperorNameList.get(numOfEmperorNum));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>单例模式是23个设计模式中比较简单的模式，应用也很广泛，最最常见的，Spring中的Bean就是单例的。Spring可以管理这些Bean，决定他们什么时候创建，什么时候销毁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;这里举个例子，古代的时候，一般只会有一个皇帝，比如秦朝。可以这样理解，皇帝是一个类，秦始皇则是一个对象实例。只会有一个皇帝实例，不然就乱套了
      
    
    </summary>
    
      <category term="设计模式" scheme="http://nastublog.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://nastublog.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-策略模式(Strategy)</title>
    <link href="http://nastublog.com/2018/06/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-Strategy/"/>
    <id>http://nastublog.com/2018/06/10/设计模式-策略模式-Strategy/</id>
    <published>2018-06-10T06:16:24.000Z</published>
    <updated>2018-07-31T15:41:24.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>写代码时总会出很多的if…else，或者case。如果在一个条件语句中又包含了多个条件语句就会使得代码变得臃肿，维护的成本也会加大，而策略模式就能较好的解决这个问题。<br> &lt; !–more–&gt;</p><h1 id="策略模式的定义和使用场景"><a href="#策略模式的定义和使用场景" class="headerlink" title="策略模式的定义和使用场景"></a>策略模式的定义和使用场景</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化。</p><p>分析下定义，策略模式定义和封装了一系列的算法，它们是可以相互替换的，也就是说它们具有共性，而它们的共性就体现在策略接口的行为上，另外为了达到最后一句话的目的，也就是说让算法独立于使用它的客户而独立变化，我们需要让客户端依赖于策略接口。</p><h2 id="策略模式的使用场景："><a href="#策略模式的使用场景：" class="headerlink" title="策略模式的使用场景："></a>策略模式的使用场景：</h2><p>1.针对同一类型问题的多种处理方式，仅仅是具体行为有差别时；<br>2.需要安全地封装多种同一类型的操作时；<br>3.出现同一抽象类有多个子类，而又需要使用 if-else 或者 switch-case 来选择具体子类时。</p><h1 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h1><p><img src="/2018/06/10/设计模式-策略模式-Strategy/策略模式.png" alt="策略模式"></p><p>模式涉及到三个角色:<br><br>1.Context 环境:持有一个策略(strategy)的引用;<br><br>2.Strategy 抽象策略:这是一个抽象的角色。通常是一个抽象类或者接口。为了提供给具体策略实现接口;<br><br>3.ConcreteStrategy 具体策略:包装相关策略。</p><h1 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h1><h2 id="两个浮点数的计算"><a href="#两个浮点数的计算" class="headerlink" title="两个浮点数的计算"></a>两个浮点数的计算</h2><p>先定义一个抽象策略的接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Opretator &#123;</span><br><span class="line"></span><br><span class="line">    double opretator(double numberA, double numberB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义两个实现该抽象策略的具体策略类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class PlusOpretator implements Opretator &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public double opretator(double numberA, double numberB) &#123;</span><br><span class="line">        return numberA + numberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MinusOpretator implements Opretator &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public double opretator(double numberA, double numberB) &#123;</span><br><span class="line">        return numberA - numberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义持有策略的环境Context<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class OpretatorTest &#123;</span><br><span class="line">    private Opretator opretator;</span><br><span class="line"></span><br><span class="line">    public OpretatorTest(Opretator opretator) &#123;</span><br><span class="line">        this.opretator = opretator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double opretator(double numberA, double numberB) &#123;</span><br><span class="line">        return this.opretator.opretator(numberA, numberB);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后用Main函数测试一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        OpretatorTest plusTest = new OpretatorTest(new PlusOpretator());</span><br><span class="line">        OpretatorTest minusTest = new OpretatorTest(new MinusOpretator());</span><br><span class="line">        System.out.println(plusTest.opretator(2d, 3d));</span><br><span class="line">        System.out.println(minusTest.opretator(3d,2d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印的结果是5.0   1.0;</p><h2 id="会员价格计算"><a href="#会员价格计算" class="headerlink" title="会员价格计算"></a>会员价格计算</h2><p>用户累计消费多少后，价格的计算如下:</p><ol><li>0-10000 普通会员 原价;<br></li><li>10000-20000 VIP 9折;<br></li><li>20000-30000 SuperVIP 8折;<br></li><li>30000以上 GoldVIP 7折.<br></li></ol><p>首先定义一个价格计算的接口，也就是抽象策略<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface CalPrice &#123;</span><br><span class="line"></span><br><span class="line">    //根据原价返回一个最终的价格</span><br><span class="line">    Double calPrice(Double orgnicPrice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后实现具体四种策略：</p><p>普通会员<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Orgnic implements CalPrice &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Double calPrice(Double orgnicPrice) &#123;</span><br><span class="line">        return orgnicPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>VIP<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Vip implements CalPrice &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Double calPrice(Double orgnicPrice) &#123;</span><br><span class="line">        return orgnicPrice*0.9;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SuperVIP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class SuperVip implements CalPrice &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Double calPrice(Double orgnicPrice) &#123;</span><br><span class="line">        return orgnicPrice*0.8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GoldVIP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class GoldVip implements CalPrice &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Double calPrice(Double orgnicPrice) &#123;</span><br><span class="line">        return orgnicPrice*0.7;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义一个具体环节，比如玩家:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Player &#123;</span><br><span class="line"></span><br><span class="line">    private Double totalAmount = 0D;//客户在鹅厂消费的总额</span><br><span class="line">    private Double amount = 0D;//客户单次消费金额</span><br><span class="line">    private CalPrice calPrice = new Orgnic();//每个客户都有一个计算价格的策略，初始都是普通计算，即原价</span><br><span class="line"></span><br><span class="line">    //客户购买皮肤，就会增加它的总额</span><br><span class="line">    public void buy(Double amount) &#123;</span><br><span class="line">        this.amount = amount;</span><br><span class="line">        totalAmount += amount;</span><br><span class="line">        if (totalAmount &gt; 30000) &#123;//30000则改为金牌会员计算方式</span><br><span class="line">            calPrice = new GoldVip();</span><br><span class="line">        &#125; else if (totalAmount &gt; 20000) &#123;//类似</span><br><span class="line">            calPrice = new SuperVip();</span><br><span class="line">        &#125; else if (totalAmount &gt; 10000) &#123;//类似</span><br><span class="line">            calPrice = new Vip();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //计算客户最终要付的钱</span><br><span class="line">    public Double calLastAmount() &#123;</span><br><span class="line">        return calPrice.calPrice(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后测试一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Player player = new Player();</span><br><span class="line">        player.buy(5000D);</span><br><span class="line">        System.out.println(&quot;玩家需要付钱：&quot; + player.calLastAmount());</span><br><span class="line">        player.buy(12000D);</span><br><span class="line">        System.out.println(&quot;玩家需要付钱：&quot; + player.calLastAmount());</span><br><span class="line">        player.buy(12000D);</span><br><span class="line">        System.out.println(&quot;玩家需要付钱：&quot; + player.calLastAmount());</span><br><span class="line">        player.buy(12000D);</span><br><span class="line">        System.out.println(&quot;玩家需要付钱：&quot; + player.calLastAmount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行以后会发现，第一次是原价，第二次是九折，第三次是八折，最后一次则是七价。这样设计的好处是，客户不再依赖于具体的收费策略，依赖于抽象永远是正确的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;写代码时总会出很多的if…else，或者case。如果在一个条件语句中又包含了多个条件语句就会使得代码变得臃肿，维护的成本也会加大，而策略模
      
    
    </summary>
    
      <category term="设计模式" scheme="http://nastublog.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://nastublog.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java8学习（二）-Stream流</title>
    <link href="http://nastublog.com/2018/05/06/Java8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89-Stream%E6%B5%81/"/>
    <id>http://nastublog.com/2018/05/06/Java8学习（二）-Stream流/</id>
    <published>2018-05-06T02:32:23.000Z</published>
    <updated>2018-06-09T09:08:41.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="流的基本概念"><a href="#流的基本概念" class="headerlink" title="流的基本概念"></a>流的基本概念</h1><h2 id="1-1是流"><a href="#1-1是流" class="headerlink" title="1.1是流"></a>1.1是流</h2><p>流是Java8引入的全新概念，它用来处理集合中的数据，暂且可以把它理解为一种高级集合。</p><p>众所周知，集合操作非常麻烦，若要对集合进行筛选、投影，需要写大量的代码，而流是以声明的形式操作集合，它就像SQL语句，我们只需告诉流需要对集合进行什么操作，它就会自动进行操作，并将执行结果交给你，无需我们自己手写代码。</p><p>因此，流的集合操作对我们来说是透明的，我们只需向流下达命令，它就会自动把我们想要的结果给我们。由于操作过程完全由Java处理，因此它可以根据当前硬件环境选择最优的方法处理，我们也无需编写复杂又容易出错的多线程代码了。</p><h2 id="1-2-流的特点"><a href="#1-2-流的特点" class="headerlink" title="1.2 流的特点"></a>1.2 流的特点</h2><p>1.只能遍历一次 <br><br>我们可以把流想象成一条流水线，流水线的源头是我们的数据源(一个集合)，数据源中的元素依次被输送到流水线上，我们可以在流水线上对元素进行各种操作。一旦元素走到了流水线的另一头，那么这些元素就被“消费掉了”，我们无法再对这个流进行操作。当然，我们可以从数据源那里再获得一个新的流重新遍历一遍。<br><br>2.采用内部迭代方式 <br><br>若要对集合进行处理，则需我们手写处理代码，这就叫做外部迭代。而要对流进行处理，我们只需告诉流我们需要什么结果，处理过程由流自行完成，这就称为内部迭代。</p><h2 id="1-3-流的操作种类"><a href="#1-3-流的操作种类" class="headerlink" title="1.3 流的操作种类"></a>1.3 流的操作种类</h2><p>流的操作分为两种，分别为中间操作 和 终端操作。<br><br>1.中间操作<br><br>当数据源中的数据上了流水线后，这个过程对数据进行的所有操作都称为“中间操作”。<br>中间操作仍然会返回一个流对象，因此多个中间操作可以串连起来形成一个流水线。<br><br>2.终端操作 <br><br>当所有的中间操作完成后，若要将数据从流水线上拿下来，则需要执行终端操作。<br>终端操作将返回一个执行结果，这就是你想要的数据。</p><p><img src="/2018/05/06/Java8学习（二）-Stream流/streamOperation.jpg" alt="流的操作种类"></p><h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><p>map()的类型推断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; collected = Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;hello&quot;).map(string-&gt;string.toUpperCase()).collect(collectors.toList());</span><br></pre></td></tr></table></figure></p><p>map()里的实现方法是函数式接口</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;流的基本概念&quot;&gt;&lt;a href=&quot;#流的基本概念&quot; class=&quot;headerlink&quot; title=&quot;流的基本概念&quot;&gt;&lt;/a&gt;流的基本概念&lt;/h1&gt;&lt;h2 id=&quot;1-1是流&quot;&gt;&lt;a href=&quot;#1-1是流&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Java学习" scheme="http://nastublog.com/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Stream流" scheme="http://nastublog.com/categories/Java%E5%AD%A6%E4%B9%A0/Stream%E6%B5%81/"/>
    
    
  </entry>
  
  <entry>
    <title>Java8学习(一)-常见的函数式接口</title>
    <link href="http://nastublog.com/2018/05/05/Java8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://nastublog.com/2018/05/05/Java8学习（一）-Lambda表达式/</id>
    <published>2018-05-05T07:04:42.000Z</published>
    <updated>2018-05-05T08:07:39.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在学习Java8的新特性之前，我们需要对函数式接口有一个初步的了解。</p><h1 id="什么是函数式接口"><a href="#什么是函数式接口" class="headerlink" title="什么是函数式接口"></a>什么是函数式接口</h1><p>函数式接口（Functional Interface）就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。<br><br>注:抽象方法就是只有方法声明，没有方法实现体的方法。抽象方法一般存在于抽象类或者接口中。<br></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><code>从JKD8开始，添加了一种新功能-默认方法。默认方法允许接口方法定义默认实现，而所有子类都将拥有该方法及实现。</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface DefaultFuncInter &#123;</span><br><span class="line">    int getInt();</span><br><span class="line">    default String getString()&#123;</span><br><span class="line">        return &quot;Default String&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="函数式接口的特点"><a href="#函数式接口的特点" class="headerlink" title="函数式接口的特点"></a>函数式接口的特点</h1><p>1  函数式接口里允许定义默认方法：<br><br>函数式接口里是可以包含默认方法，因为默认方法不是抽象方法，其有一个默认实现，所以是符合函数式接口的定义的；<br><br>2 函数式接口里允许定义静态方法：<br><br>函数式接口里是可以包含静态方法，因为静态方法不能是抽象方法，是一个已经实现了的方法，所以是符合函数式接口的定义的；<br><br>3  函数式接口里允许定义java.lang.Object里的public方法：<br><br>函数式接口里是可以包含Object里的public方法，这些方法对于函数式接口来说，不被当成是抽象方法（虽然它们是抽象方法）；因为任何一个函数式接口的实现，默认都继承了Object类，包含了来自java.lang.Object里对这些抽象方法的实现；<br><br>4  函数式接口里允许子接口继承多个父接口，但每个父接口中都只能存在一个抽象方法，且必须的相同的抽象方法。<br><br>注:如果多个父接口中有各自不同的抽象方法，则子接口也会存在继承多个抽象方法，此时，子接口就不是函数式接口。</p><p>下面给出几个函数式接口的例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Predicate&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    boolean test(T t);</span><br><span class="line"></span><br><span class="line">    default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        return (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    default Predicate&lt;T&gt; negate() &#123;</span><br><span class="line">        return (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) &#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        return (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) &#123;</span><br><span class="line">        return (null == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="FunctionalInterface注解"><a href="#FunctionalInterface注解" class="headerlink" title="@FunctionalInterface注解"></a>@FunctionalInterface注解</h1><p>Java 8为函数式接口引入了一个新注解@FunctionalInterface，主要用于编译级错误检查，加上该注解，当你写的接口不符合函数式接口定义的时候，编译器会报错。加不加@FunctionalInterface对于接口是不是函数式接口没有影响，该注解只是提醒编译器去检查该接口是否仅包含一个抽象方法。</p><h1 id="四种基本的函数式接口"><a href="#四种基本的函数式接口" class="headerlink" title="四种基本的函数式接口"></a>四种基本的函数式接口</h1><p>现在介绍一下四种最基本的函数式接口，为了节约篇幅，只给出这些函数式接口里的抽象方法。</p><h4 id="1-Predicate-接口：接受一个T类型参数，返回boolean类型值。"><a href="#1-Predicate-接口：接受一个T类型参数，返回boolean类型值。" class="headerlink" title="1.Predicate 接口：接受一个T类型参数，返回boolean类型值。"></a>1.Predicate<t> 接口：接受一个T类型参数，返回boolean类型值。</t></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean test(T t);</span><br></pre></td></tr></table></figure><h4 id="2-Function-lt-T-R-gt-功能接口：接受一个T类型参数，返回R类型值。"><a href="#2-Function-lt-T-R-gt-功能接口：接受一个T类型参数，返回R类型值。" class="headerlink" title="2.Function&lt;T, R&gt; 功能接口：接受一个T类型参数，返回R类型值。"></a>2.Function&lt;T, R&gt; 功能接口：接受一个T类型参数，返回R类型值。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R apply(T t);</span><br></pre></td></tr></table></figure><h4 id="3-Supplier-接口：无参数，返回一个T类型值。"><a href="#3-Supplier-接口：无参数，返回一个T类型值。" class="headerlink" title="3.Supplier 接口：无参数，返回一个T类型值。"></a>3.Supplier<t> 接口：无参数，返回一个T类型值。</t></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T get();</span><br></pre></td></tr></table></figure><h4 id="4-Consumer-接口：接受一个T类型参数，无返回值。"><a href="#4-Consumer-接口：接受一个T类型参数，无返回值。" class="headerlink" title="4.Consumer 接口：接受一个T类型参数，无返回值。"></a>4.Consumer<t> 接口：接受一个T类型参数，无返回值。</t></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void accept(T t);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;在学习Java8的新特性之前，我们需要对函数式接口有一个初步的了解。&lt;/p&gt;
&lt;h1 id=&quot;什么是函数式接口&quot;&gt;&lt;a href=&quot;#什么是
      
    
    </summary>
    
      <category term="Java学习" scheme="http://nastublog.com/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="函数式接口" scheme="http://nastublog.com/categories/Java%E5%AD%A6%E4%B9%A0/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习---泛型总结</title>
    <link href="http://nastublog.com/2018/05/03/Java%E6%B3%9B%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://nastublog.com/2018/05/03/Java泛型总结/</id>
    <published>2018-05-03T15:30:21.000Z</published>
    <updated>2018-07-31T15:41:01.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>泛型是Java中一个非常重要的知识点，在Java集合类框架中泛型被广泛应用。本文我们将从零开始来看一下Java泛型的设计，将会涉及到通配符处理，以及让人苦恼的类型擦除。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>泛型在Java中有着很重要的地位，在面向对象的变成和设计模式中有着广泛的应用。<br><br>什么是泛型?为什么要使用泛型?<br><br>泛型，即”参数化类型”。一提到参数，最熟悉的就是定义方式时有形参，然后调用此方法时传递实参。<br><br>参数化类型，顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在调用的时候传入类型实参</p><h1 id="泛型基础"><a href="#泛型基础" class="headerlink" title="泛型基础"></a>泛型基础</h1><p>我们首先定义一个简单的Box类：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Box &#123;</span><br><span class="line">    private String object;</span><br><span class="line">    public void set(String object) &#123; this.object = object; &#125;</span><br><span class="line">    public String get() &#123; return object; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 泛型方法的基本介绍</span><br><span class="line"> * @param tClass 传入的泛型实参</span><br><span class="line"> * @return T 返回值为T类型</span><br><span class="line"> * 说明：</span><br><span class="line"> *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span><br><span class="line"> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span><br><span class="line"> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span><br><span class="line"> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span><br><span class="line"> */</span><br><span class="line">public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException ,</span><br><span class="line">  IllegalAccessException&#123;</span><br><span class="line">        T instance = tClass.newInstance();</span><br><span class="line">        return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;泛型是Java中一个非常重要的知识点，在Java集合类框架中泛型被广泛应用。本文我们将从零开始来看一下Java泛型的设计，将会涉及到通配符处
      
    
    </summary>
    
      <category term="Java" scheme="http://nastublog.com/categories/Java/"/>
    
    
      <category term="泛型" scheme="http://nastublog.com/tags/%E6%B3%9B%E5%9E%8B/"/>
    
      <category term="Java" scheme="http://nastublog.com/tags/Java/"/>
    
  </entry>
  
</feed>
