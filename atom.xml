<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夏至微风</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nastublog.com/"/>
  <updated>2018-08-19T15:13:14.604Z</updated>
  <id>http://nastublog.com/</id>
  
  <author>
    <name>なつ初夏倾城</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工作流引擎</title>
    <link href="http://nastublog.com/2018/08/19/%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <id>http://nastublog.com/2018/08/19/工作流/</id>
    <published>2018-08-19T07:57:16.000Z</published>
    <updated>2018-08-19T15:13:14.604Z</updated>
    
    <content type="html"><![CDATA[<p>从开始接手现在项目的流程开发到现在，也算接触了大半年的工作流引擎，很长一段时间内，都是为了完成任务式的去编写代码，没有对其有一个更深入的思考，知道去百世汇通面试回来，面试过程中，面试官也没有多问技术上的问题，而是一直在问实现方式、以及为什么要这么实现?其中印象比较深的一个问题就是，你们为什么要引入工作流引擎，它的意义在哪。</p><p>面试官首先提出，你所说的业务场景，我用一般的方法都可以实现，为什么还要用工作流?</p><p>当时我也比较懵逼，但是，随着面试官的循循善诱式的发问，我逐渐了解到了工作流引擎的意义。</p><p>首先，我们要明白，工作流是什么？工作流(Workflow)，就是业务过程的部分或整体在计算机应用环境下的自动化。是对工作流程及各操作步骤之间的业务规则的抽象、概括描述。</p><p>工作流主要解决的问题就是：在一个业务流程中，为了实现某一个业务目标，利用计算机在多个参与者之间按照一开始制定好的规则自动传递文档、信息或者任务。</p><p>工作流引擎就是将工作流作为业务应用系统的一部分，解决包括流程设计、流程流转、节点管理等功能。</p><p>说到这里，可能有的人已经明白，工作流引擎引入的意义就是将业务逻辑和流程处理逻辑分离，没错，大概上就是这么个意思。</p><p>我们可以举个例子(这里引用的是CSDN知名博主的例子)：</p><p><img src="/2018/08/19/工作流/workflow.png" alt=""></p><p>这是一个比较简单的业务流程，实现了订货这个需求：</p><p>1.首先由客户提交采购的订单；<br>2.然后由业务员执行订单处理，这边流程产生了分支，也就是不同条件的流向不同；<br>3.如果缺货，先是通知工厂生产，然后仓库出货；<br>4.如果货物尚有存余，则仓库直接出货；<br>5.由物流发货</p><p>我们可以思考一下，如果我们不使用工作流技术，去开发这个流程的业务逻辑，需要做什么，这么做又有什么问题?</p><p>1.首先，针对这个流程中的每一个活动，我们都需要单独为其编写处理逻辑，以及前台交互页面；<br>2.每个节点办理完成后，到下一个节点之前，我们都需要编写代码去判断当前条件，以及设置下一个节点的审批人；<br>3.每次操作都需要我们去修改业务数据和流程数据。    </p><p>最终结果就如下图:<br><img src="/2018/08/19/工作流/workflow2.png" alt=""></p><p>好的，后期我们流程发生了变更，新加了一个活动节点，我们又需要为其编写额外代码实现其逻辑，不仅如此，新加入的节点还会对之前已有的节点代码产生影响，比如加在了A和B之间，A原本指定下个节点审批人的代码肯定需要修改，不仅繁琐，而且维护麻烦。</p><p>但是，如果我们使用了工作流技术，会产生什么样的变化？</p><p><img src="/2018/08/19/工作流/workflow3.png" alt=""></p><p>从上图可以看出，引入了工作流引擎后，实现了业务逻辑和流程数据的分离:</p><p>1.工作流引擎专门去维护流程的数据，不需要我们在编写业务代码的时候还去维护流程数据；<br>2.现在大部分的流程引擎，都提供了流程设计工具，让我们基于可视化的页面去配置业务流程的节点和流转方向；<br>3.大多数工作流引擎都提供了众多api方便我们进行二次开发，比如activiti，现在所在的项目就基于activiti的api开发了许多额外扩展功能。</p><p>所以说，项目中引入工作流，对于基础开发来说，十分有益处：<br>1.降低了开发风险，减少了业务人员通技术沟通交流的成本，节点、活动、状态、流转这种术语，技术同业务都能理解；<br>2.加快开发，开发者不必再去手动设置流程的参与者、节点的链接等等，这些都交给了流程引擎去实现；<br>3.降低了需求变更的风险，因为流程可以重新部署，所以就算之后流程发生了改变，也不需要大面积的去修改代码。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/xiaoxian8023/article/details/34468739" target="_blank" rel="noopener">从程序员的角度来看为什么我们需要工作流</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从开始接手现在项目的流程开发到现在，也算接触了大半年的工作流引擎，很长一段时间内，都是为了完成任务式的去编写代码，没有对其有一个更深入的思考，知道去百世汇通面试回来，面试过程中，面试官也没有多问技术上的问题，而是一直在问实现方式、以及为什么要这么实现?其中印象比较深的一个问
      
    
    </summary>
    
      <category term="Activiti" scheme="http://nastublog.com/categories/Activiti/"/>
    
    
      <category term="工作流" scheme="http://nastublog.com/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    
      <category term="Activiti" scheme="http://nastublog.com/tags/Activiti/"/>
    
      <category term="BPMN" scheme="http://nastublog.com/tags/BPMN/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-工厂模式(Factory)</title>
    <link href="http://nastublog.com/2018/08/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-Factory/"/>
    <id>http://nastublog.com/2018/08/16/设计模式-工厂模式-Factory/</id>
    <published>2018-08-16T14:29:32.000Z</published>
    <updated>2018-08-16T14:34:29.463Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="设计模式" scheme="http://nastublog.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://nastublog.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock实现及AQS源代码深入解析</title>
    <link href="http://nastublog.com/2018/08/09/ReentrantLock%E6%BA%90%E4%BB%A3%E7%A0%81%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"/>
    <id>http://nastublog.com/2018/08/09/ReentrantLock源代码深入解析/</id>
    <published>2018-08-09T12:37:44.000Z</published>
    <updated>2018-08-12T01:57:00.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>JDK1.5中最引人注目的的便是concurrent包，Doug Lea这名神一样的男人，在JDK1.5中为我们为我们引入了这个包，让并发程序的开发变得更加得心应手，谈到并发，我们不得不谈ReentrantLock，而谈到ReentrantLock，我们就不得不介绍AbstractQueuedSynchronized（AQS）。<br>类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock、CountDownLatch等。<br>网上关于ReentrantLock的文章有很多很多，介绍其与synchronized的区别的文章也很多，但大多数都很片面，直到今天，拜读了一位博主的文章，跟着他的文章，打开ReentrantLock的源码，一起阅读，终于对其有了一定的理解，也十分佩服Doug Lea的思维，现在，就让我们跟随大师的思路，一起来研究一下ReentrantLock的源码。</p><h1 id="AbstractQueuedSynchronizer-AQS"><a href="#AbstractQueuedSynchronizer-AQS" class="headerlink" title="AbstractQueuedSynchronizer(AQS)"></a>AbstractQueuedSynchronizer(AQS)</h1><p>ReentrantLock实现的前提就是AbstractQueuedSynchronized(AQS),这个类是cocurrent包的核心，CountDownLatch、ReentrantLock、FutureTask等都有一个内部类是这个抽象类的子类,AQS是典型的模板方法设计模式的应用，其中大部分方法都由AQS本身实现好，我们在应该时，只需要重写部分方法就行，如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到这个方法只是抛出了一个异常，需要我们在子类中重写，那么为什么不把方法定义成抽象方法呢，因为Doug Lea考虑到:一般独占锁只需要重写tryAcquire()和tryRelease()方法，共享锁只需要实现tryAcquireShared()和tryRelease()方法，为了减少我们编程人员的工作量，才不将方法设置为抽象方法。</p><p>由于AQS是基于FIFO的队列实现，队列肯定由一个个Node节点组成，我们先来看一下Node的属性</p><table><thead><tr><th>属    性</th><th>多进程</th></tr></thead><tbody><tr><td>Node SHARED = new Node()</td><td>表示Node处于共享模式</td></tr><tr><td>Node EXCLUSIVE = null</td><td>表示Node处于共享模式</td></tr><tr><td>int CANCELLED = 1</td><td>因为超时或者中断，Node被设置为取消状态，被取消的Node不应该去竞争锁，只能保持取消状态不变，不能转换为其他状态，处于这种状态的Node会被踢出队列，被GC回收</td></tr><tr><td>int SIGNAL = -1</td><td>表示这个Node的继任Node被阻塞了，到时需要通知它</td></tr><tr><td>int CONDITION = -2</td><td>表示这个Node在条件队列中，因为等待某个条件而被阻塞</td></tr><tr><td>int PROPAGATE = -3</td><td>使用在共享模式头Node有可能处于这种状态， 表示锁的下一次获取可以无条件传播</td></tr><tr><td>int waitStatus</td><td>0，新Node会处于这种状态</td></tr><tr><td>Node prev</td><td>队列中某个Node的前驱Node</td></tr><tr><td>Node next</td><td>队列中某个Node的后继Node</td></tr><tr><td>Thread thread</td><td>这个Node持有的线程，表示等待锁的线程</td></tr><tr><td>Node nextWaiter</td><td>表示下一个等待condition的Node</td></tr></tbody></table><h1 id="ReentrantLock的源码实现"><a href="#ReentrantLock的源码实现" class="headerlink" title="ReentrantLock的源码实现"></a>ReentrantLock的源码实现</h1><p>先来看ReentrantLock里最基本的结构，废话少说，上源码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">     sync = new NonfairSync();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">  * Creates an instance of &#123;@code ReentrantLock&#125; with the</span><br><span class="line">  * given fairness policy.</span><br><span class="line">  *</span><br><span class="line">  * @param fair &#123;@code true&#125; if this lock should use a fair ordering policy</span><br><span class="line">  */</span><br><span class="line"> public ReentrantLock(boolean fair) &#123;</span><br><span class="line">     sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>首先是ReentrantLock的构造函数，从中可以看出，其构造函数分为无参和有参的构造函数，无参的构造函数默认生成一个NonfairSync的对象，而有参的构造函数根据传入的boolean类型的值，如果是true，则生成一个FairSync的对象，如果是false，则生成NonfairSync的对象。<br>FairSync和NonfairSync分别代表什么呢?他们对应的其实就是锁中的公平锁和非公平锁的概念，那么什么是公平锁，什么是非公平锁呢，这里简单介绍一下，好让大家有个概念?<br>举个例子吧，我们去火车站买票，看到拍了很长的队伍，这时候，不同的情况我们会采取不同的做法，第一种情况，我们有很多时间，不着急，我们选择去队伍一个一个排队，这就是公平的，第二种情况，我们时间很紧，我们走到最前面，问柜员我们是否能先买票，因为我们赶时间，这就是不公平，当然，我们会得到两个结果，比较通情理的柜员就会让我们先买，或者让我们冲新区排队。<br>这个例子或许很抽象，但是，放到并发编程的概念里，就是，公平锁就是严格按照线程的顺序获取锁，而非公平锁，则是可以插队执行，这之后的源代码会介绍到，非公平锁在加锁的方法中，都会先执行一次抢占锁的方法，这就突出了非公平的概念。<br>而从构造方法来看，默认的ReentrantLock都是非公平的。<br></p><p>继续往下看，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private final Sync sync;</span><br><span class="line"></span><br><span class="line">abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">        private static final long serialVersionUID = -5179523762034025860L;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Performs &#123;@link Lock#lock&#125;. The main reason for subclassing</span><br><span class="line">         * is to allow fast path for nonfair version.</span><br><span class="line">         */</span><br><span class="line">        abstract void lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先ReentrantLock内部存在着一个静态的抽象类Sync继承了AbstractQueuedSynchronizer，这个静态类拥有抽象的lock方法，而其子类也就是FairSync和NonfairSync继承了Sync并实现了不同的lock()方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">        private static final long serialVersionUID = -3000897897090466540L;</span><br><span class="line"></span><br><span class="line">        final void lock() &#123;</span><br><span class="line">            acquire(1);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> static final class NonfairSync extends Sync &#123;</span><br><span class="line">        private static final long serialVersionUID = 7316153563782823691L;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Performs lock.  Try immediate barge, backing up to normal</span><br><span class="line">         * acquire on failure.</span><br><span class="line">         */</span><br><span class="line">        final void lock() &#123;</span><br><span class="line">            if (compareAndSetState(0, 1))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            else</span><br><span class="line">                acquire(1);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到源码，NonfairSync的lock方法，每次都会先执行一次CAS操作，去判断state是不是0，是0就设置为1，然后将AbstractOwnableSynchronizer的thread设置为当前线程，这就是之前提到的不公平的概念，因为ReentrantLock的默认实现是不公平的，所以本文之后着重讲述NonfairSync，有兴趣的之后可以去看一下FairSync源码，区别不大，基本就是lock()和tryAcquire()存在区别。<br></p><p>假设现在有两个线程，线程1和线程2，线程1调用了ReentrantLock的lock()方法，这样线程1就会独占这个锁，可以看一下整个调用链，十分简单，</p><p><img src="/2018/08/09/ReentrantLock源代码深入解析/线程1.png" alt="线程1"></p><p>对应的代码就是NonfairSync里面的lock()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">          if (compareAndSetState(0, 1))</span><br><span class="line">              setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">          else</span><br><span class="line">              acquire(1);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><p>首先执行CAS操作，因为是第一个线程，所以AQS里的state必定为0，也就是未锁状态，线程1在执行了这段代码后，将AQS的state设置为1，也就是抢占了改锁，并执行  setExclusiveOwnerThread()方法，看一下该方法源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> public abstract class AbstractOwnableSynchronizer</span><br><span class="line">    implements java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    /** Use serial ID even though all fields transient. */</span><br><span class="line">    private static final long serialVersionUID = 3737899427754241961L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Empty constructor for use by subclasses.</span><br><span class="line">     */</span><br><span class="line">    protected AbstractOwnableSynchronizer() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The current owner of exclusive mode synchronization.</span><br><span class="line">     */</span><br><span class="line">    private transient Thread exclusiveOwnerThread;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Sets the thread that currently owns exclusive access.</span><br><span class="line">     * A &#123;@code null&#125; argument indicates that no thread owns access.</span><br><span class="line">     * This method does not otherwise impose any synchronization or</span><br><span class="line">     * &#123;@code volatile&#125; field accesses.</span><br><span class="line">     * @param thread the owner thread</span><br><span class="line">     */</span><br><span class="line">    protected final void setExclusiveOwnerThread(Thread thread) &#123;</span><br><span class="line">        exclusiveOwnerThread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the thread last set by &#123;@code setExclusiveOwnerThread&#125;,</span><br><span class="line">     * or &#123;@code null&#125; if never set.  This method does not otherwise</span><br><span class="line">     * impose any synchronization or &#123;@code volatile&#125; field accesses.</span><br><span class="line">     * @return the owner thread</span><br><span class="line">     */</span><br><span class="line">    protected final Thread getExclusiveOwnerThread() &#123;</span><br><span class="line">        return exclusiveOwnerThread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是AbstractOwnableSynchronizer里面的方法，他将该抽象类里的exclusiveOwnerThread设为当前线程也就是线程1.</p><p>这两步操作做完之后线程1就独占了锁。然后此时线程2也想获得这个锁，调用了lock()方法，我们知道，在线程1没释放锁的情况下，这个操作肯定是行不通的，所以线程2必定被阻塞，那么线程2是怎么被阻塞的呢?我们看一下方法的调用链，如下图:<br><img src="/2018/08/09/ReentrantLock源代码深入解析/线程2.png" alt="线程2"></p><p>当我第一次看到这张图的时候，心里不免产生恐惧，哇，这么长的调用链，不要慌，随着源码一步一步看下去，你会发现，并没有你想的那么恐怖,首先，还是看lock()方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">           if (compareAndSetState(0, 1))</span><br><span class="line">               setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">           else</span><br><span class="line">               acquire(1);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>首先，线程2还是通过CAS去尝试着改变state的值，毕竟不公平嘛，但是免谈，我线程1还没释放这个锁呢，你就想来抢，state仍然为1，抢占锁失败，于是便执行acquire(1)，继续看acquire()方法源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">       if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>acquire()源码是AQS类提供的模板方法，其中tryAcquire是由我们子类去重写的，也就是ReentrantLock重写的，该模板方法也很好理解，先走第一个判断条件尝试获取一次锁，如果获取的结果为false即失败，走第二个判断条件添加FIFO等待队列。所以先看一下tryAcquire()方法做了什么，我们看一下ReentrantLock的tryAcquire()方法，tryAcquire()在FairSync和NonFairSync里面有着不同的实现，因为前面说过了，着重讲非公平的实现，我们就看一下NonFairSync里的tryAcquire()方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">          return nonfairTryAcquire(acquires);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>可以看到，该方法继续调用了nonfairTryAcquire()方法，继续跟踪:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">            final Thread current = Thread.currentThread();</span><br><span class="line">            int c = getState();</span><br><span class="line">            if (c == 0) &#123;</span><br><span class="line">                if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc = c + acquires;</span><br><span class="line">                if (nextc &lt; 0) // overflow</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>首先获取当前线程，然后获取当前state，因为state是被volatile修饰的，所以对线程2具有可见性，线程2拿到了最新的state，再次判断一下state是否为0，也就是锁是否被释放了，为什么这么做，因为可能线程1执行同步代码块较快，已经释放了锁，不可以就返回false，然后false非就是true，就会走第二个判断acquireQueued(addWaiter(Node.EXCLUSIVE), arg)去添加FIFO的等待队列。<br>这里注意一下else if的判断，这段代码的作用就是实现了可重入锁，就是让某个线程可以多次使用ReentrantLock，如果当前线程等于getExclusiveOwnerThread()取到的线程，也就是之前我们通过setExclusiveOwnerThread()设置的线程，直接就会执行内部代码，不需要再进行CAS操作，每调用一次，就会将state加1，当nextc&lt;0的时候抛出error，什么时候nextc会小于0，就是超过了int的最大值的时候，那么同一个锁最多能重入Integer.MAX_VALUE次，也就是2147483647次。</p><p>继续走acquireQueued(addWaiter(Node.EXCLUSIVE), arg)方法，先看addWaiter(Node.EXCLUSIVE)方法，该方法位于AQS类中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">        Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">        // Try the fast path of enq; backup to full enq on failure</span><br><span class="line">        Node pred = tail;</span><br><span class="line">        if (pred != null) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先创建一个当前线程的Node，因为传入的参数是Node.EXCLUSIVE，也就是独占模式，mode也就是null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node(Thread thread, Node mode) &#123;     // Used by addWaiter</span><br><span class="line">          this.nextWaiter = mode;</span><br><span class="line">          this.thread = thread;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>看一下Node对应的构造参数，意思就是这个node的线程是当前线程也就是线程2，下一个等待者是null。<br>然后判断队列中有没有节点，我们这里的情况肯定是没有节点的，于是执行endq(node)方法，传入参数为之前创建的node，也就是线程2所在的node，看一下endq()方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            if (t == null) &#123; // Must initialize</span><br><span class="line">                if (compareAndSetHead(new Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    return t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>endq()方法也是AQS内部的，可以看到内部是一次循环的函数，直到return才会退出循环。传入线程2所在的node后，还是先判断队列是否为空，通过取得tail尾部node，判断是否为null的方式实现，由于我们这个例子中线程2所在的node是第一个要等待的node，所以必定为空，于是通过CAS设置了头node为一个新的Node，这里执行的new Node()是一个无参的构造函数，然后将tail指向head也就是头node，然后继续第二次循环，此时通过Node t = tail 取到的t 就是第一次我们新建的Node对象，执行else的逻辑，首先将我们传入进来的node(线程2所在的node)的prev也就是前驱node设为之前新建的Node，然后执行CAS操作，将AQS里的tail也就是队列尾node设为线程2所在的node，然后将头node的next也就是后继node设为线程2所在的node，然后返回，注意，这里返回的是t，也就是头node(之前通过new Node()新建的node)。</p><p>回到addWaiter()方法，此时，我们通过endq()方法新建了一个队列，队列的结构大概如下图:<br><img src="/2018/08/09/ReentrantLock源代码深入解析/队列.png" alt="队列"></p><p>这是个双向队列，然后执行acquireQueued()方法，看一下acquireQueued()方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">        boolean failed = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean interrupted = false;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                final Node p = node.predecessor();</span><br><span class="line">                if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先定义了两个boolean类型的值，fail为true，interrupted为为false，继续进入循环，这里先调用node.predecessor()方法，看一下源代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final Node predecessor() throws NullPointerException &#123;</span><br><span class="line">           Node p = prev;</span><br><span class="line">           if (p == null)</span><br><span class="line">               throw new NullPointerException();</span><br><span class="line">           else</span><br><span class="line">               return p;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>可以看出是返回node的前驱节点，这里的node就是线程2所在的node，而其前驱节点就是头结点，证明该节点是FIFO队列的理论上的第一个节点(头结点没有意义，是空节点)，所以满足p == head，因为&amp;&amp;的特性，会继续执行后面的tryAcquire()，会尝试再次获取一次锁(因为在前面这段操作时间内，线程1可能已经执行完毕，state重新变成了0)，如果成功，则表示线程2所在的node已经成功获取到了锁，也就代表着其可以从FIFO队列出队，所以讲前面取到的head节点的后继节点设为null，然后将failed置为false(这里不太理解，failed用于finally函数中，也就是try执行完毕或者发生异常后会通过判断failed<br>的值去决定是否执行cancelAcquire()方法)，返回interrupted也就是false，回到acquire()方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">        if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>返回false，不会执行selfInterrupt()方法。</p><p>如果尝试获取所失败，则走第二个if判断也就是 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;parkAndCheckInterrupt())，先看shouldParkAfterFailedAcquire(p,node)方法，分别传入了头节点和线程2所在的节点作为参数，看一下shouldParkAfterFailedAcquire()实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">        int ws = pred.waitStatus;</span><br><span class="line">        if (ws == Node.SIGNAL)</span><br><span class="line">            /*</span><br><span class="line">             * This node has already set status asking a release</span><br><span class="line">             * to signal it, so it can safely park.</span><br><span class="line">             */</span><br><span class="line">            return true;</span><br><span class="line">        if (ws &gt; 0) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">             * indicate retry.</span><br><span class="line">             */</span><br><span class="line">            do &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /*</span><br><span class="line">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">             * need a signal, but don&apos;t park yet.  Caller will need to</span><br><span class="line">             * retry to make sure it cannot acquire before parking.</span><br><span class="line">             */</span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法位于AQS类中，先获取pred的waitStatus，也就是头节点的waitStatus，我们这里头节点是一个默认生成的节点，其waitStatus就是int的默认值也就是0，然后进行判断，会走最后一个代码块，通过CAS操作将waitStatus更新SIGNAL也就是-1，然后返回false，因为返回false，if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())，根据短路&amp;&amp;的逻辑parkAndCheckInterrupt()自然不会执行，然后会再走一次for循环，此时依然会像前面一样再次尝试获取锁，获取失败的话再次进入shouldParkAfterFailedAcquire(p, node)方法，这时候ws取到的是前面更新过的值，也就是SIGNAL,然后返回true，于是就会执行parkAndCheckInterrupt()方法，看一下parkAndCheckInterrupt()源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        return Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到调用了LockSupport的park方法阻塞住了当前的线程，看一下park()的源码，它是LockSupport类中的一个静态方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void park(Object blocker) &#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        setBlocker(t, blocker);</span><br><span class="line">        UNSAFE.park(false, 0L);</span><br><span class="line">        setBlocker(t, null);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>获取到了当前线程，通过UNSAFE的一系列操作阻塞了当前线程，这里不详细讲述UNSAFE的原理，因为我也不清楚，有兴趣的同学可以下载OpenJDK的源码详细看一下UNSAFE的实现机制。</p><p>上面的流程总结下来，大概就是通过调用ReentrantLock实现线程1独占锁，线程2进入AQS中的FIFO队列并阻塞的整个过程，可以看出来，整个过程十分精妙，AQS的设计就是一个典型的模板方法设计模式，他的子类也就是ReentrantLock只是实现了tryAcquire()方法，其余的方法都由AQS实现好了，并且其中多个方法都有着尝试再次获取锁的操作，这换做是我，一定只会在刚开始判断一下，大师不愧是大师，多读源码，才能更好地了解大师的想法。</p><p>上面讲述了lock()的实现过程，下面来看一下unlock()也就是释放锁的实现过程。</p><p>首先调用ReentrantLock的unlock()方法，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">       sync.release(1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后看一下release()方法,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">       if (tryRelease(arg)) &#123;</span><br><span class="line">           Node h = head;</span><br><span class="line">           if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">               unparkSuccessor(h);</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>很明显，tryRelase()是AQS提供的抽象方法，具体的实现肯定由子类来实现，我们看一下ReentrantLock里的tryRelease()方法，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">           int c = getState() - releases;</span><br><span class="line">           if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">               throw new IllegalMonitorStateException();</span><br><span class="line">           boolean free = false;</span><br><span class="line">           if (c == 0) &#123;</span><br><span class="line">               free = true;</span><br><span class="line">               setExclusiveOwnerThread(null);</span><br><span class="line">           &#125;</span><br><span class="line">           setState(c);</span><br><span class="line">           return free;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>首先可以看到如果当前线程和getExclusiveOwnerThread()返回的线程不相等，会直接抛出IllegalMonitorStateException()异常，那当然了，你都没有获得锁，你又怎么去释放锁。</p><p>然后每次调用unlock()方法，就会取当前AQS内部的state并减1，只有当c==0的时候，才会让free为true并返回，这对应着就是我们上面的可重入方法，一个线程可以多次调用ReentrantLock的lock()方法，对应着，你调用了多少次lock()方法就需要调用同样次数的unlock()方法，当c == 0 的时候，也就意味着该线程对当前的ReentrantLock全部解锁，于是通过setExclusiveOwnerThread(null)方法把AbstractOwnableSynchronizer的exclusiveOwnerThread将被设置为null，这样就表示没有线程占有锁，然后返回true，执行大括号内部的代码。</p><p>此时取到AQS内部的FIFO的head节点，依然是之前new Node()产生的节点，h!=null成立，而其waitStatus之前被更新成了SIGNAL状态也就是-1，所以h != null &amp;&amp; h.waitStatus != 0成立，执行unparkSuccessor(h)方法，来看一下unparkSuccessor()方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * If status is negative (i.e., possibly needing signal) try</span><br><span class="line">         * to clear in anticipation of signalling.  It is OK if this</span><br><span class="line">         * fails or if status is changed by waiting thread.</span><br><span class="line">         */</span><br><span class="line">        int ws = node.waitStatus;</span><br><span class="line">        if (ws &lt; 0)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Thread to unpark is held in successor, which is normally</span><br><span class="line">         * just the next node.  But if cancelled or apparently null,</span><br><span class="line">         * traverse backwards from tail to find the actual</span><br><span class="line">         * non-cancelled successor.</span><br><span class="line">         */</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">            s = null;</span><br><span class="line">            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                if (t.waitStatus &lt;= 0)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s != null)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先取到传入的node也就是head节点的status也就是-1，-1&lt;0，执行CAS操作将head的status转为-1，然后取到node的next也就是后继节点，也就是线程2所在的节点，s!=null成立，执行 LockSupport.unpark(s.thread)，线程2就被unpark了。</p><p>有人会疑惑了，线程2得以运行后，线程2所在的节点又是怎么退出AQS内部的FIFO队列的呢?我们来回溯一下之前的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">        boolean failed = true;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean interrupted = false;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                final Node p = node.predecessor();</span><br><span class="line">                if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>线程2是在parkAndCheckInterrupt()处被阻塞的，当锁释放，线程2得以继续运行时，并没有return语句，只是将interrupted置为true，于是会再次进入循环，这时候，p == head 和 tryAcquire(arg)都会返回true，进入内部，首先执行setHeader(node)方法，这里要特别注意了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void setHead(Node node) &#123;</span><br><span class="line">        head = node;</span><br><span class="line">        node.thread = null;</span><br><span class="line">        node.prev = null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>线程2所在的node被设置为了头结点，且节点内部的thread变量被设置成了null，且prev也被设置成了null，然后把p的next设置为null，这样原头Node里面的所有对象都不指向任何块内存空间，方法结束后被自动回收，而原先线程2所在的node成了新的头结点(此时内部thread变量已经为null，也就是此时node不属于任何一个线程)，此时，遇到一个return语句，acquireQueued方法结束，返回interrupted，这里我产生了一个一位，此时的interrupted是true还是false，这里要看一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = true;</span><br></pre></td></tr></table></figure><p>这段代码，因为之前说到，线程2是调用的 parkAndCheckInterrupt()进行阻塞的，再看一下parkAndCheckInterrupt()源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">       LockSupport.park(this);</span><br><span class="line">       return Thread.interrupted();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里return的是Thread.interrupted()方法得到的返回值，然后我们看一下Thread类的interrupted()网上的介绍:</p><p>Thread.interrupted()测试当前线程是否已经中断，线程的中断状态也是由该方法清除。默认返回false，如果当前线程之前通过调用interrupt()导致处于中断状态，则会返回false并清除中断状态，下次再次调用依然会返回false，这样就比较好理解了，如果当前线程是出于中断状态，parkAndCheckInterrupt()返回true， interrupted也就是中断标志被设置为true，acquireQueued()返回值就是true，返回true的话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">        if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看出来就会执行selfInterrupt()中断当前线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void selfInterrupt() &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这大概就是我理解的ReentrantLock的大致过程，有的地方依旧比较模糊，如果之后有想通的会再来补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;JDK1.5中最引人注目的的便是concurrent包，Doug Lea这名神一样的男人，在JDK1.5中为我们为我们引入了这个包，让并发程
      
    
    </summary>
    
      <category term="并发" scheme="http://nastublog.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="http://nastublog.com/tags/Java/"/>
    
      <category term="并发" scheme="http://nastublog.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="源码" scheme="http://nastublog.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>synchronized关键字详解</title>
    <link href="http://nastublog.com/2018/08/08/synchronized/"/>
    <id>http://nastublog.com/2018/08/08/synchronized/</id>
    <published>2018-08-08T07:20:17.000Z</published>
    <updated>2018-08-19T05:10:22.552Z</updated>
    
    <content type="html"><![CDATA[<p>在JDK1.5出现前，线程的同步大部分都是由关键字synchronized实现的，顾名思义，就是保证代码在多线程的环境下，控制被synchronized修饰的代码不被同步执行。synchronized既可以加在一段代码上，也可以加在方法上。但是，不同情况下，sychronized的情况也不同，比如，加在普通方法上、加在静态方法上、修饰代码块，这些不同的情况下，sychronized锁住的究竟是什么？</p><h1 id="内置锁"><a href="#内置锁" class="headerlink" title="内置锁"></a>内置锁</h1><p>首先，使用sychronized，我们需要了解一个概念，那就是内置锁。</p><p>Java的内置锁：每个Java对象都可以用做一个实现同步的锁，这些锁被称为内置锁或者监视器锁。线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得内置锁的唯一途径就是进入这个锁的保护的同步代码块或方法。</p><p>Java内置锁是一个互斥锁，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的内置锁时，线程A必须等待或者阻塞，直到线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。</p><p>由于每次只能有一个线程执行内置锁保护的代码块，因此，由这个锁保护的同步代码块或者方法会以原子方式执行，多个线程在执行该代码块或者方法时也不会互相干扰。何为原子性，这与事务中的定义大致相同，就是一组语句是作为一个不可被分割的单元执行的，保证原子性是并发编程实现线程安全的必要条件。</p><h1 id="sychronized的原理"><a href="#sychronized的原理" class="headerlink" title="sychronized的原理"></a>sychronized的原理</h1><p>我们知道，sychronized在Java中有两种使用方法:<br>1.加在方法前，修饰方法，可以分为普通方法和静态方法，他们之间的不同稍后会讨论到；<br>2.同步代码块方式，此时锁住的是括号里的对象。</p><p>但是，sychronized是如何实现的呢，先看一段简单的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class TestSynchronized &#123;</span><br><span class="line"></span><br><span class="line">    public synchronized void test1() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void test2() &#123;</span><br><span class="line">        synchronized (this)&#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面分别展示了两种使用synchronized的方法，现在我们用javac编译一下这个java文件，并用javap查看一下生成的class文件来看一下synchronized的实现机制：</p><p><img src="/2018/08/08/synchronized/sychronized.png" alt=""></p><p>我们可以看到，test2()方法也就是同步代码块的实现，是借助monitorenter和monitorexit指令实现的，而同步方法在这里看不出来实现方法，看到网上的资料说是借助读取常量池中方法发的ACC_SYNCHRONIZED标志来实现的，需要看JVM的底层源码，具体可以参考以下博文：<br><a href="https://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">深入理解Java并发之synchronized实现原理</a></p><p>当同步代码块执行到monitorenter指令时，就会尝试获取对象monitor的所有权，这里其实就是我们上面说到的内置锁，也就是监视器锁(monitor锁)。任何一个对象都有着自己对应的monitor，当一个monitor被持有后，他将处于一个锁定的状态，知道执行到monitorexit指令，才会被释放。</p><h1 id="synchronized的使用"><a href="#synchronized的使用" class="headerlink" title="synchronized的使用"></a>synchronized的使用</h1><p>首先看一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Sync &#123;</span><br><span class="line"></span><br><span class="line">    public  void test() &#123;</span><br><span class="line">       synchronized (this) &#123;</span><br><span class="line">            System.out.println(&quot;test开始..&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;test结束..&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Sync sync = new Sync();</span><br><span class="line">        sync.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            Thread thread = new MyThread();</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行如上代码,运行结果是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test开始..</span><br><span class="line">test开始..</span><br><span class="line">test开始..</span><br><span class="line">test结束..</span><br><span class="line">test结束..</span><br><span class="line">test结束..</span><br></pre></td></tr></table></figure></p><p>test开始和结束间隔一秒，可以看出来，三个线程是同时执行的，貌似synchronized没起作用。<br>把synchronized加到方法的前面，运行结果也是一样的，你可能会疑惑，为什么不起作用呢?<br>因为synchronized加在方法上，锁住的是当前对象，而synchronized(this)修饰的代码块，锁住的是括号里的内容，也是当前对象，而上面的代码在for循环了new了三个对象，也就是产生了三个Sync对象，由于不是同一个对象，所以可以多线程同时运行synchronized方法或代码段。</p><p>那么，我们来修改一下上面的代码，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Sync &#123;</span><br><span class="line"></span><br><span class="line">    public  void test() &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            System.out.println(&quot;test开始..&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;test结束..&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    private Sync sync;</span><br><span class="line"></span><br><span class="line">    public MyThread(Sync sync) &#123;</span><br><span class="line">        this.sync = sync;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        sync.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Sync sync = new Sync();</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            Thread thread = new MyThread(sync);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码输出结果是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test开始..</span><br><span class="line">test结束..</span><br><span class="line">test开始..</span><br><span class="line">test结束..</span><br><span class="line">test开始..</span><br><span class="line">test结束..</span><br></pre></td></tr></table></figure></p><p>可以看到，此时的synchronized就起了作用。 因为，在main方法中，只新建了一个sync对象，Mythread的构造函数传入了这个sync对象，for循环创建了3个线程，执行test方法。<br>因为test方法被synchronized修饰，别的线程要执行，必须要拿到sync这个对象的锁，而要拿到这个锁，就必须等待这个线程执行完成释放锁，才能再次给对象加锁，这样才达到线程同步的目的。</p><p>当然，我们还有另一种写法，就是给Sync这个类加锁，也就是类锁，类锁能保证只要是这个类产生这个对象，在调用这个方法时，都会产生互斥。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Sync &#123;</span><br><span class="line"></span><br><span class="line">    public  void test() &#123;</span><br><span class="line">        synchronized (Sync.class) &#123;</span><br><span class="line">            System.out.println(&quot;test开始..&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;test结束..&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Sync sync = new Sync();</span><br><span class="line">        sync.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">            Thread thread = new MyThread();</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的运行结果是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test开始..</span><br><span class="line">test结束..</span><br><span class="line">test开始..</span><br><span class="line">test结束..</span><br><span class="line">test开始..</span><br><span class="line">test结束..</span><br></pre></td></tr></table></figure></p><p>可以看到，三个线程是先后执行的，因为synchronized后面的括号不是this，而是Sync.class，锁住的是这个类，所以，所有Sync类产生的对象再执行这段同步代码块时，都会产生互斥。</p><h1 id="对象锁和类锁"><a href="#对象锁和类锁" class="headerlink" title="对象锁和类锁"></a>对象锁和类锁</h1><p>那么，你或许会疑问，synchronized什么时候锁住的是对象，什么时候锁住的是类呢，对象锁和类锁又有什么区别呢，下面给出我的理解：</p><ol><li>sychronized加在普通方法前，如sychronized method()，此时锁住的是对象；</li><li>sychronized加在静态方法前，如static sychronized method()，此时锁住的是类；</li><li>sychronized修饰代码块，此时锁住的是括号里的内容，如果括号里的是类的class对象，则此时锁住的是类，不然就是对象。</li></ol><p>Java的对象锁和类锁：Java的对象锁和类锁在锁的概念上基本上和内置锁是一致的，但是，两个锁实际是有很大的区别的，对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。</p><p>对象锁和类锁控制着不同的区域，他们之间互不影响，互不干扰，线程获得对象锁的同时，也可以获得类锁。<font color="orange" size="4">但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别的。</font></p><p>如果觉得比较难理解，附上一段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package Synchronized;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 类锁和对象锁</span><br><span class="line"> * @Date: Created in 23:37 2018/8/2</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class TestSynchronized &#123;</span><br><span class="line">    public void test1() &#123;</span><br><span class="line">        synchronized (TestSynchronized.class) &#123;</span><br><span class="line">            int i = 5;</span><br><span class="line">            while (i-- &gt; 0) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(500);</span><br><span class="line">                &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void test2() &#123;</span><br><span class="line">        int i = 5;</span><br><span class="line">        while (i-- &gt; 0) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(500);</span><br><span class="line">            &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TestSynchronized myt2 = new TestSynchronized();</span><br><span class="line">        Thread test1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                myt2.test1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;test1&quot;);</span><br><span class="line">        Thread test2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                myt2.test2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;test2&quot;);</span><br><span class="line">        test1.start();</span><br><span class="line">        test2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的运行结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test1 : 4</span><br><span class="line">test2 : 4</span><br><span class="line">test1 : 3</span><br><span class="line">test2 : 3</span><br><span class="line">test1 : 2</span><br><span class="line">test2 : 2</span><br><span class="line">test1 : 1</span><br><span class="line">test2 : 1</span><br><span class="line">test2 : 0</span><br><span class="line">test1 : 0</span><br></pre></td></tr></table></figure><p>可以看到，test1和test2是交替执行的，而在代码中，synchronized (TestSynchronized.class)和synchronized void test2()，一个修饰的是括号里的内容，也就是TestSynchronized.class，从之前的概念来看，这是个类锁，另一个修饰的是test2()方法，这是一个对象锁，两个互相管理不同的区域，所以test1和test2线程可以交替执行，如果把synchronized(TestSynchronized.class)换成synchronized(this)，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void test1() &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            int i = 5;</span><br><span class="line">            while (i-- &gt; 0) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(500);</span><br><span class="line">                &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行结果就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test1 : 4</span><br><span class="line">test1 : 3</span><br><span class="line">test1 : 2</span><br><span class="line">test1 : 1</span><br><span class="line">test1 : 0</span><br><span class="line">test2 : 4</span><br><span class="line">test2 : 3</span><br><span class="line">test2 : 2</span><br><span class="line">test2 : 1</span><br><span class="line">test2 : 0</span><br></pre></td></tr></table></figure><p>可以看到，test2是知道test1执行完后才执行的，因为此时synchronized(this)获取的也是对象锁，所以test2必须等到test1执行完释放锁后才能执行。</p><p>如果还不理解，我多附上几段代码，分别看一下他们的执行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package Synchronized;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 类锁和对象锁</span><br><span class="line"> * @Date: Created in 23:37 2018/8/2</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class TestSynchronized &#123;</span><br><span class="line">    public void test1() &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            int i = 5;</span><br><span class="line">            while (i-- &gt; 0) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);</span><br><span class="line">                try &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(500);</span><br><span class="line">                &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized void test2() &#123;</span><br><span class="line">        int i = 5;</span><br><span class="line">        while (i-- &gt; 0) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);</span><br><span class="line">            try &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(500);</span><br><span class="line">            &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TestSynchronized myt2 = new TestSynchronized();</span><br><span class="line">        Thread test1 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                myt2.test1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;test1&quot;);</span><br><span class="line">        Thread test2 = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                TestSynchronized.test2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;test2&quot;);</span><br><span class="line">        test1.start();</span><br><span class="line">        test2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码，test2是一个静态方法，sychronized在修饰静态方法时，执行这个方法尝试获取的锁应该是类锁，test1中的同步代码块尝试获取的应该是对象锁，两个之间互不影响，应该可以同时执行，运行一下，结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test1 : 4</span><br><span class="line">test2 : 4</span><br><span class="line">test1 : 3</span><br><span class="line">test2 : 3</span><br><span class="line">test2 : 2</span><br><span class="line">test1 : 2</span><br><span class="line">test1 : 1</span><br><span class="line">test2 : 1</span><br><span class="line">test1 : 0</span><br><span class="line">test2 : 0</span><br></pre></td></tr></table></figure><p>如果把test1方法中中括号里的this换成TestSynchronized.class</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void test1() &#123;</span><br><span class="line">       synchronized (TestSynchronized.class) &#123;</span><br><span class="line">           int i = 5;</span><br><span class="line">           while (i-- &gt; 0) &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);</span><br><span class="line">               try &#123;</span><br><span class="line">                   TimeUnit.MILLISECONDS.sleep(500);</span><br><span class="line">               &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>那么此时执行test1方法中同步代码块的内容和执行test2方法获取的应该都是类锁，所以test1和test2方法应该是先后执行的，运行结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test1 : 4</span><br><span class="line">test1 : 3</span><br><span class="line">test1 : 2</span><br><span class="line">test1 : 1</span><br><span class="line">test1 : 0</span><br><span class="line">test2 : 4</span><br><span class="line">test2 : 3</span><br><span class="line">test2 : 2</span><br><span class="line">test2 : 1</span><br><span class="line">test2 : 0</span><br></pre></td></tr></table></figure><p>所以，这也就证明了，类锁和对象锁是两个不一样的锁，他们之间互不影响，一个线程，可以同时获得类锁和对象锁，这是允许的。</p><h1 id="synchronized使用注意事项"><a href="#synchronized使用注意事项" class="headerlink" title="synchronized使用注意事项"></a>synchronized使用注意事项</h1><p>刚学习synchronized的人肯定有这样一个疑惑，既然synchronized有了修饰方法的方式，为什么还要采用synchronized修饰同步代码块的方式呢？</p><p>我们需要知道，synchronized是有其缺陷的，虽然JDK 1.5后对其进行了优化，引入了偏向锁、轻量级锁、锁粗化、锁销除等等机制来优化sychronized，但是，无法改变其根本，就是当某个线程进入同步方法获得对象锁，那么其他线程访问这里对象的同步方法时，必须等待或者阻塞，这对高并发的系统是致命的，这很容易导致系统的崩溃。</p><p>同步是一个高开销的动作，一般同步的范围越大，其性能也就越差，所以，同步代码块的使用，就是减少同步的范围，提高性能，举个例子(出自Java并发编程实战):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package net.jcip.examples;</span><br><span class="line"></span><br><span class="line">import java.math.BigInteger;</span><br><span class="line">import javax.servlet.*;</span><br><span class="line"></span><br><span class="line">import net.jcip.annotations.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * SynchronizedFactorizer</span><br><span class="line"> *</span><br><span class="line"> * Servlet that caches last result, but with unnacceptably poor concurrency</span><br><span class="line"> *</span><br><span class="line"> * @author Brian Goetz and Tim Peierls</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@ThreadSafe</span><br><span class="line">public class SynchronizedFactorizer extends GenericServlet implements Servlet &#123;</span><br><span class="line">    @GuardedBy(&quot;this&quot;) private BigInteger lastNumber;</span><br><span class="line">    @GuardedBy(&quot;this&quot;) private BigInteger[] lastFactors;</span><br><span class="line"></span><br><span class="line">    public synchronized void service(ServletRequest req,</span><br><span class="line">                                     ServletResponse resp) &#123;</span><br><span class="line">        BigInteger i = extractFromRequest(req);</span><br><span class="line">        if (i.equals(lastNumber))</span><br><span class="line">            encodeIntoResponse(resp, lastFactors);</span><br><span class="line">        else &#123;</span><br><span class="line">            BigInteger[] factors = factor(i);</span><br><span class="line">            lastNumber = i;</span><br><span class="line">            lastFactors = factors;</span><br><span class="line">            encodeIntoResponse(resp, factors);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInteger extractFromRequest(ServletRequest req) &#123;</span><br><span class="line">        return new BigInteger(&quot;7&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInteger[] factor(BigInteger i) &#123;</span><br><span class="line">        // Doesn&apos;t really factor</span><br><span class="line">        return new BigInteger[] &#123; i &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里采取的同步方法就是synchronized修饰service()方法，虽然能实现同步，但是，这背离了Servlet框架的设计初衷，在这段代码里，service()方法每次只有一个线程可以执行，在并发量很大的情况下，这会给用户带来很糟糕的体验，如果service()方法需要执行很长时间，那么其他的客户端就必须一直等待，这时候我们就可以采用同步代码块的方式，在service()方法内部执行同步操作，降低锁的范围，提高性能。</p><p>所以，我们在编写代码，使用synchronized代码块同步关键代码即可，除非同步代码块无法满足我们的需求，否则尽量不要用同步方法的方式。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面的文章只是针对synchronized的使用作了简单的介绍，简单的介绍了一下monitor对象，但是由于monitor监视器锁的操作是基于操作系统的底层Mutex Lock实现的，对所要加锁线程加上互斥锁，但是加锁时间相比其他指令就长很多了，因此将这种基于互斥锁的加锁机制被称为重量级锁。<br>而在JDK1.6以后，对sychronized进行的优化，根据不同情形出现了偏向锁、轻量锁、对象锁，自旋锁（或自适应自旋锁）等，因此，现在的synchronized可以说是一个几种锁过程的封装。具体synchronized优化，找个时间总结一下，再写一篇博文介绍一下。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/QQParadise/articles/5059824.html" target="_blank" rel="noopener">synchronized锁住的是代码还是对象</a><br><a href="http://zhh9106.iteye.com/blog/2151791" target="_blank" rel="noopener">java synchronized关键字的用法</a><br><a href="https://blog.csdn.net/shandian000/article/details/54927876" target="_blank" rel="noopener">深入分析synchronized的实现原理</a><br><a href="https://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">深入理解Java并发之synchronized实现原理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在JDK1.5出现前，线程的同步大部分都是由关键字synchronized实现的，顾名思义，就是保证代码在多线程的环境下，控制被synchronized修饰的代码不被同步执行。synchronized既可以加在一段代码上，也可以加在方法上。但是，不同情况下，sychroni
      
    
    </summary>
    
      <category term="并发" scheme="http://nastublog.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://nastublog.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="synchronized" scheme="http://nastublog.com/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>Java四种引用方式</title>
    <link href="http://nastublog.com/2018/08/05/Java%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
    <id>http://nastublog.com/2018/08/05/Java四种引用方式/</id>
    <published>2018-08-05T08:53:21.000Z</published>
    <updated>2018-08-07T03:12:05.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>今天在看ThreadLocal源码的时候，看到了内部有一个WeakReference类，不知道这是什么意思，一查原来代表的是Java里的弱引用，想到自己对引用这块比较模糊，就去看了一下有关引用的文章，然后写一个总结记录一下自己的新的。</p><h1 id="Java四种引用"><a href="#Java四种引用" class="headerlink" title="Java四种引用"></a>Java四种引用</h1><h2 id="Java四种引用的类型"><a href="#Java四种引用的类型" class="headerlink" title="Java四种引用的类型"></a>Java四种引用的类型</h2><p>从JDK1.2版本起，Java把引用分为四个等级，平时我们用的最多的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object object = new Object()</span><br></pre></td></tr></table></figure></p><p>就是四种里面的第一级别-强引用，而剩下的三中引用分别是软引用、弱引用和虚引用，这四个对内存的敏感程度分别为:强引用-软引用-弱引用-虚引用。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>Java为什么要给我们提供这四个引用呢，主要有两个目的：<br>1.可以让我们程序员通过代码决定对象的生命周期；<br>2.有利于JVM进行垃圾回收。</p><p>下面我们就分别一一阐述这四种引用。</p><h1 id="强引用-StrongReference）"><a href="#强引用-StrongReference）" class="headerlink" title="强引用(StrongReference）"></a>强引用(StrongReference）</h1><p>StrongReference只是对强引用的一种称呼，其他三种引用在Java中都有对应的类，但是强引用并没有。强引用是我们平时用的最多的、最普遍的引用类型。如下面这段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object object = new Object();</span><br><span class="line">String str = &quot;hello&quot;;</span><br></pre></td></tr></table></figure></p><p>其中obj和str都是强引用。<br>使用强引用的对象就算是内存出现OOM（OutOfMemory）的异常也不会回收。也就是说该对象永远不会被垃圾回收器回收，不论内存是否充足。</p><p>可以看个Demo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package Refrence;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Date: Created in 17:12 2018/8/5</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class StrongRefrence &#123;</span><br><span class="line">    static Object object = new Object();</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object obj = object;</span><br><span class="line">        object = null;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.print(&quot;after system.gc-strongReference---obj = &quot; + object);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">after system.gc-strongReference---obj = java.lang.Object@60e53b93</span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></p><p>虽然obj所指向的对象被置为null,但gc不会回收该强引用对象.</p><p>但是，我们可以显示的将引用赋值为null，弱化引用和对象之间的关联，这样gc就可以在合适的时间去回收这个对象，具体什么时候收集这要取决于gc的算法。<br>PS:Vector类的clear方法中就是通过将引用赋值为null来实现清理工作的,看一下源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Removes all of the elements from this Vector.  The Vector will</span><br><span class="line">    * be empty after this call returns (unless it throws an exception).</span><br><span class="line">    *</span><br><span class="line">    * @since 1.2</span><br><span class="line">    */</span><br><span class="line">   public void clear() &#123;</span><br><span class="line">       removeAllElements();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    /**</span><br><span class="line">    * Removes all components from this vector and sets its size to zero.</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt;This method is identical in functionality to the &#123;@link #clear&#125;</span><br><span class="line">    * method (which is part of the &#123;@link List&#125; interface).</span><br><span class="line">    */</span><br><span class="line">   public synchronized void removeAllElements() &#123;</span><br><span class="line">       modCount++;</span><br><span class="line">       // Let gc do its work</span><br><span class="line">       for (int i = 0; i &lt; elementCount; i++)</span><br><span class="line">           elementData[i] = null;</span><br><span class="line"></span><br><span class="line">       elementCount = 0;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h1 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h1><p>软引用是用来描述一些有用但并不是必需的对象，在Java中用SoftReference类来表示<br>如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；<br>如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str=new String(&quot;abc&quot;);                                     // 强引用</span><br><span class="line">SoftReference&lt;String&gt; softRef=new SoftReference&lt;String&gt;(str);     // 软引用</span><br></pre></td></tr></table></figure></p><p>上面这段代码中，str就是一个强引用，softRef就是一个软引用。<br>从软引用的定义可以看出，软引用十分适合用于实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。<br>实际上来说，Web浏览器的后退、前进就适合软引用，如果内存足够，就从缓存里取，省去了网页加载的时间，如果内存不足够，就重新加载。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Browser prev = new Browser();               // 获取页面进行浏览</span><br><span class="line">SoftReference sr = new SoftReference(prev); // 浏览完毕后置为软引用        </span><br><span class="line">if(sr.get()!=null)&#123; </span><br><span class="line">    rev = (Browser) sr.get();           // 还没有被回收器回收，直接获取</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    prev = new Browser();               // 由于内存吃紧，所以对软引用的对象回收了</span><br><span class="line">    sr = new SoftReference(prev);       // 重新构建</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><h1 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h1><p>在强度上弱于软引用，通过类WeakReference来表示。它的作用是引用一个对象，但是并不阻止该对象被回收。如果使用一个强引用的话，只要该引用存在，那么被引用的对象是不能被回收的。弱引用则没有这个问题。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。<br>弱引用最常见的用处是在集合类中，尤其在哈希表中。哈希表的接口允许使用任何Java对象作为键来使用。当一个键值对被放入到哈希表中之后，哈希表对象本身就有了对这些键和值对象的引用。如果这种引用是强引用的话，那么只要哈希表对象本身还存活，其中所包含的键和值对象是不会被回收的。如果某个存活时间很长的哈希表中包含的键值对很多，最终就有可能消耗掉JVM中全部的内存<br>对于这种情况的解决办法就是使用弱引用来引用这些对象，这样哈希表中的键和值对象都能被垃圾回收。Java中提供了WeakHashMap来满足这一常见需求。</p><p>弱引用也可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><h1 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h1><p>虚引用，又被称为幽灵引用，顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。<br>可以看一下虚引用的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class PhantomReference&lt;T&gt; extends Reference&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns this reference object&apos;s referent.  Because the referent of a</span><br><span class="line">     * phantom reference is always inaccessible, this method always returns</span><br><span class="line">     * &lt;code&gt;null&lt;/code&gt;.</span><br><span class="line">     *</span><br><span class="line">     * @return  &lt;code&gt;null&lt;/code&gt;</span><br><span class="line">     */</span><br><span class="line">    public T get() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates a new phantom reference that refers to the given object and</span><br><span class="line">     * is registered with the given queue.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; It is possible to create a phantom reference with a &lt;tt&gt;null&lt;/tt&gt;</span><br><span class="line">     * queue, but such a reference is completely useless: Its &lt;tt&gt;get&lt;/tt&gt;</span><br><span class="line">     * method will always return null and, since it does not have a queue, it</span><br><span class="line">     * will never be enqueued.</span><br><span class="line">     *</span><br><span class="line">     * @param referent the object the new phantom reference will refer to</span><br><span class="line">     * @param q the queue with which the reference is to be registered,</span><br><span class="line">     *          or &lt;tt&gt;null&lt;/tt&gt; if registration is not required</span><br><span class="line">     */</span><br><span class="line">    public PhantomReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123;</span><br><span class="line">        super(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，虚引用的创建必须和引用队列(ReferenceQueue)联合使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。这样子程序就可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。<br>虚引用主要用于对象销毁前的一些操作，比如说资源释放等。为什么不用finalize，因为这个方法既不安全又低效，具体可以参考<a href="https://blog.csdn.net/aitangyong/article/details/39450341" target="_blank" rel="noopener">Effective Java Item7:Avoid Finalizers,解释为什么finalize是不安全的，不建议使用</a>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章只是大致粗略介绍了一下四种引用，关于其详细用法和具体应用场景并没有过多描述，还有比较重要的引用队列(ReferenceQueue)的使用方法也没有具体提交，等博主好好研究一下再来完善这篇文章。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cnblogs.com/gudi/p/6403953.html" target="_blank" rel="noopener">Java 的强引用、弱引用、软引用、虚引用</a><br><a href="https://www.cnblogs.com/mjorcen/p/3968018.html" target="_blank" rel="noopener">java中四种引用类型</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;今天在看ThreadLocal源码的时候，看到了内部有一个WeakReference类，不知道这是什么意思，一查原来代表的是Java里的弱引
      
    
    </summary>
    
      <category term="Java" scheme="http://nastublog.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://nastublog.com/tags/Java/"/>
    
      <category term="引用" scheme="http://nastublog.com/tags/%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之线程(Thread)的状态和相关方法</title>
    <link href="http://nastublog.com/2018/08/04/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B-Thread-%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://nastublog.com/2018/08/04/Java并发编程之线程-Thread-的状态和相关方法/</id>
    <published>2018-08-04T10:55:02.000Z</published>
    <updated>2018-08-07T03:34:25.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>网上很多关于线程状态的文章，但是很多都没有基于Java的源代码来分析，今天偶然看到一篇基于Java源代码来分析线程状态的文章，看完之后感触颇深，于是想着写一篇Blog总结一下。</p><h1 id="Java中线程的六大状态"><a href="#Java中线程的六大状态" class="headerlink" title="Java中线程的六大状态"></a>Java中线程的六大状态</h1><p>在Java中，线程的状态是Thread类里的一个枚举类型来描述的。这个枚举类型一共六个值，分别是:NEW、RUNNABLE、BLOCKED、TIMED_WAITING、WAITING、TERMINATED。<br>下面就是Thread类描述线程状态的源码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public enum State &#123;</span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a thread which has not yet started.</span><br><span class="line">         */</span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a runnable thread.  A thread in the runnable</span><br><span class="line">         * state is executing in the Java virtual machine but it may</span><br><span class="line">         * be waiting for other resources from the operating system</span><br><span class="line">         * such as processor.</span><br><span class="line">         */</span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a thread blocked waiting for a monitor lock.</span><br><span class="line">         * A thread in the blocked state is waiting for a monitor lock</span><br><span class="line">         * to enter a synchronized block/method or</span><br><span class="line">         * reenter a synchronized block/method after calling</span><br><span class="line">         * &#123;@link Object#wait() Object.wait&#125;.</span><br><span class="line">         */</span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a waiting thread.</span><br><span class="line">         * A thread is in the waiting state due to calling one of the</span><br><span class="line">         * following methods:</span><br><span class="line">         * &lt;ul&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #join() Thread.join&#125; with no timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span><br><span class="line">         * &lt;/ul&gt;</span><br><span class="line">         *</span><br><span class="line">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span><br><span class="line">         * perform a particular action.</span><br><span class="line">         *</span><br><span class="line">         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span><br><span class="line">         * on an object is waiting for another thread to call</span><br><span class="line">         * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span><br><span class="line">         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span><br><span class="line">         * is waiting for a specified thread to terminate.</span><br><span class="line">         */</span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a waiting thread with a specified waiting time.</span><br><span class="line">         * A thread is in the timed waiting state due to calling one of</span><br><span class="line">         * the following methods with a specified positive waiting time:</span><br><span class="line">         * &lt;ul&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #sleep Thread.sleep&#125;&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span><br><span class="line">         *   &lt;li&gt;&#123;@link LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span><br><span class="line">         * &lt;/ul&gt;</span><br><span class="line">         */</span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Thread state for a terminated thread.</span><br><span class="line">         * The thread has completed execution.</span><br><span class="line">         */</span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>NEW(初始):新创建了一个线程对象，但还没有调用start()方法。<br>RUNNABLE(运行):很多文章都有提到过线程在运行前有个READY(就绪),运行中则是RUNNING(运行中)，Java中将READY和RUNNING笼统的称为RUNNABLE。创建了线程对象后，其他线程(比如主线程main)调用了该线程对象的start()方法</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/GooPolaris/p/8079490.html" target="_blank" rel="noopener">Java中一个线程只有六个状态。至于阻塞、可运行、挂起状态都是人们为了便于理解，自己加上去的。</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;网上很多关于线程状态的文章，但是很多都没有基于Java的源代码来分析，今天偶然看到一篇基于Java源代码来分析线程状态的文章，看完之后感触颇
      
    
    </summary>
    
      <category term="并发" scheme="http://nastublog.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="http://nastublog.com/tags/Java/"/>
    
      <category term="并发" scheme="http://nastublog.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="线程" scheme="http://nastublog.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程之基础概念</title>
    <link href="http://nastublog.com/2018/08/03/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://nastublog.com/2018/08/03/Java并发编程之基础概念/</id>
    <published>2018-08-03T02:54:56.000Z</published>
    <updated>2018-08-07T03:25:10.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近还是一直在准备面试这块的内容，大多数互联网公司面试，避免不了的会问到并发这块的内容，所以，准备写几篇Blog来总结一下Java并发方面知识，于是就先写一篇最基础的，也就是并发编程中涉及到的基础概念，因为主要是想到什么写什么，所以可能会有遗漏，就当看个热闹吧。<br>这边文章参考了网上众多文章，并加上了自己的理解，也可能会有理解不周到的地方，如有错误，请及时指出。</p><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>进程(Process):具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配的一个独立单位（PS:若不支持线程机制，进程也是系统调度的单位。否则，线程是系统调度的单位。因为随着cpu的性能越来越好，所以才将资源分配和调度分开，于是才有了线程这个概念）。比如我们打开一个程序，这个程序就是一个进程。</p><p>线程(Thread or Lightweight Process LWP):从其英文定义可以看出，线程也可以被称之为轻量级进程。线程是进程的一个实体，是程序执行流的最小单元。<br>通常将进程看作是分配资源的最小单位，而线程则是操作系统调度的最小单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p><h2 id="进程和线程的关系以及区别"><a href="#进程和线程的关系以及区别" class="headerlink" title="进程和线程的关系以及区别"></a>进程和线程的关系以及区别</h2><p>1.线程是进程的组成部分，一个进程可以拥有很多线程，但至少有一个线程，但是一个线程只能属于一个进程；<br>2.操作系统的资源是分配给进程的，同一进程内的线程共享该进程的所有资源,但CPU是分配给线程的，即真正在处理及上运行的是线程；<br>3、不同的进程使用不同的内存空间，而一个进程内的所有线程共享父进程所拥有的全部空间，这极大提高了程序的运行效率(PS:内存空间不同于栈空间，每个线程都拥有单独的栈内存用来存储本地数据。线程拥有自己的堆栈、自己的程序计数器和自己的局部变量，但他不拥有系统资源)；<br>4.线程的调度和管理由进程本身负责完成。操作系统对进程进行调度，管理和资源分配；<br>5.同一个进程的线程之间可以直接通信，但是进程之间的交流需要借助中间代理来实现；<br>6.一个线程可以操作同一进程的其他线程，但是进程只能操作其子进程;<br>7.线程的启动速度快，进程的启动速度慢。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>Java原生并不提供对协程的支持，但有的框架模拟出了协程的功能，比如Kilim框架，这里我们就简单提一下协程的概念。<br>协程(Coroutines)，是一种比线程更加轻量级的存在。一个进程可以拥有多个线程，一个线程也可以拥有多个协程。<br>协程的切换不是被操作系统的内核管理，而是直接由程序控制<br>线程进程都是同步机制，而协程则是异步。协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。<br>协程的暂停完全由程序控制，而线程之间状态的切换是由操作系统的内核实现的，所以协程的开销远远小于线程的开销。</p><h1 id="多进程和多线程"><a href="#多进程和多线程" class="headerlink" title="多进程和多线程"></a>多进程和多线程</h1><p>就拿我们平时使用电脑来举个例子:<br>1.我们打开chrome浏览器，用浏览器一边下载文件、一边听歌、一边看网页，这就是多线程；<br>2.我们同时打开了QQ、微信、浏览器等，这就是多进程。</p><h2 id="多进程和多线程的比较"><a href="#多进程和多线程的比较" class="headerlink" title="多进程和多线程的比较"></a>多进程和多线程的比较</h2><p>从上面例子，我们从来分析一下多进程和多线程之间的优劣势</p><table><thead><tr><th>对比维度</th><th>多进程</th><th>多线程</th><th>总结</th></tr></thead><tbody><tr><td>数据共享、同步</td><td>数据共享复杂，需要用IPC；数据是分开的，同步简单</td><td>因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂</td><td>各有优势</td></tr><tr><td>内存、CPU</td><td>占用内存多，切换复杂，CPU利用率低</td><td>占用内存少，切换简单，CPU利用率高</td><td>线程占优</td></tr><tr><td>数据共享、同步</td><td>数据共享复杂，需要用IPC；数据是分开的，同步简单</td><td>因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂</td><td>各有优势</td></tr><tr><td>创建销毁、切换</td><td>创建销毁、切换复杂，速度慢</td><td>创建销毁、切换简单，速度很快</td><td>线程占优</td></tr><tr><td>编程、调试</td><td>编程简单，调试简单</td><td>编程复杂，调试复杂</td><td>进程占优</td></tr><tr><td>可靠性</td><td>进程间不会相互影响</td><td>因为共享进程数据，所以导致一旦一个线程挂掉，整个进程也会随之挂掉</td><td>进程占优</td></tr><tr><td>分布式</td><td>适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单</td><td>适应于多核分布式</td><td>进程占优</td></tr></tbody></table><h2 id="多线程的好处"><a href="#多线程的好处" class="headerlink" title="多线程的好处"></a>多线程的好处</h2><p>1.同一进程的线程之间共享内存，但是进程之间不能共享内存；<br>2.系统创建进程需要重新为其分配系统资源，但是线程并不需要，所以代价会小很多，效率也会更高；<br>3.资源利用率更好；<br>4.程序设计更加简单；<br>5.程序响应更快。<br>这里可以参考<a href="http://ifeve.com/benefits/" target="_blank" rel="noopener">并发编程网</a><br>总而言之，随着CPU性能的越来越好，多线程可以让我们充分利用CPU的资源，帮助我们编写出高性能高效率的程序。</p><h1 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>从时间上来说，并行是指两个或多个时间在同一时刻同时发生，而并发则是指两个或多个事件在同一时间段内同时发生；<br>从空间上来说，并行实在多个不同实体上进行的，而并发是在同一个实体上进行的。<br>并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。</p><h2 id="图片解释"><a href="#图片解释" class="headerlink" title="图片解释"></a>图片解释</h2><p><img src="/2018/08/03/Java并发编程之基础概念/并发和并行.png" alt="并发和并行"></p><h2 id="现实场景"><a href="#现实场景" class="headerlink" title="现实场景"></a>现实场景</h2><p>举个惊悚点的例子:<br>普通人只有1个脑子，一边吃饭一边说话，其实有脑子有任务切换在里面，所以是并发。(PS：只是因为这个切换速度非常快，所以让人产生了是并行的感觉)<br>一个双脑人，一个脑吃饭，一个脑说话，俩脑子彼此独立互不冲突，这是并行。<br>一个双脑人，一个脑子吃饭+看书，一个脑子说话，这是并行中含有并发(有个脑子在轮换吃饭 和 看书)。<br>一个三脑人，一个脑子吃饭，一个脑子看书，一个脑子说话，这是并行。<br>让一个CPU执行多个【可并行 ( 可分解，可单独核心运行)】 的任务，就是并发(concurrence)<br>多个CPU分别执行【可并行】任务，就是并行(parallel)<br>在现实中<br>单核的机器，都是并发 concurrence 执行的。<br>多核的机器，都是并行 parallel 中嵌套着并发 concurrence 运行的。<br>如果存在无限核心的机器，则所有任务都可以是并行运行的。</p><h1 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每一次只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源，就必须等待。</p><h2 id="画图解释"><a href="#画图解释" class="headerlink" title="画图解释"></a>画图解释</h2><p><img src="/2018/08/03/Java并发编程之基础概念/临界区.png" alt="临界区"></p><h2 id="现实场景-1"><a href="#现实场景-1" class="headerlink" title="现实场景"></a>现实场景</h2><p>打印机，我们工作的时候肯定会经常用到打印机，打印机就是一个临界区的最好例子。一台打印机一次只能执行一个任务，如果 A 和 B 同时需要打印文件，很显然，如果 A 先发下打印的任务，打印机就开始打印 A 的文件。B 的任务就只能等待 A 打印结束之后才能打印。</p><h1 id="同步和异步、阻塞和非阻塞"><a href="#同步和异步、阻塞和非阻塞" class="headerlink" title="同步和异步、阻塞和非阻塞"></a>同步和异步、阻塞和非阻塞</h1><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>同步和异步通常用来形容一次方法的调用。<br>同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。<br>异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，但调用者并不一定会得到结果，而且调用者可以继续后续的操作。</p><h3 id="图片解释-1"><a href="#图片解释-1" class="headerlink" title="图片解释"></a>图片解释</h3><p><img src="/2018/08/03/Java并发编程之基础概念/同步和异步.png" alt="同步和异步"></p><h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><p>这里把同步异步和阻塞非阻塞放在一起，主要是很多时候对这几个概念有点模糊，这里具体说一下。<br>同步和异步关心的是消息传输机制，而阻塞非阻塞关心的是程序在等待调用结果返回时的状态。<br>所以上面四种概念，会有四种组合方式，分别是:<br>同步阻塞、同步非阻塞、异步阻塞和异步非阻塞。</p><h2 id="现实场景-2"><a href="#现实场景-2" class="headerlink" title="现实场景"></a>现实场景</h2><p>这样讲会可能比较抽象，那我们继续结合实际来说一下，首先是烧水的例子，我们拥有两个水壶，一个是会响的水壶，简称响水壶，一个是普通水壶。<br>1.用普通水壶煮水，并且站在那里，不管水开没开，每隔一定时间看看水开了没。－同步阻塞<br>2.还是用普通水壶煮水，不再傻傻的站在那里看水开，跑去寝室上网，但是还是会每隔一段时间过来看看水开了没有，水没有开就走人。－同步非阻塞<br>3.使用高大上的响水壶来煮水，站在那里，但是不会再每隔一段时间去看水开，而是等水开了，水壶会自动的通知他。－异步阻塞<br>4.还是使用响水壶煮水，跑到客厅上网去，等着响水壶自己把水煮熟了以后通知他。－异步非阻塞</p><p>这里可以看出<br>同步就是烧开水，需要自己去轮询（每隔一段时间去看看水开了没），异步就是水开了，然后水壶会通知你水已经开了，你可以回来处理这些开水了。<br>同步和异步是相对于操作结果来说，就是会不会等待结果返回。<br>阻塞就是说在煮水的过程中，你不可以去干其他的事情，非阻塞就是在同样的情况下，可以同时去干其他的事情。阻塞和非阻塞是相对于线程是否被阻塞。</p><p>再讲一个下载的例子:<br>1.同步阻塞：一直盯着下载进度条，到 100% 的时候就完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">同步体现在：等待下载完成通知；</span><br><span class="line">阻塞体现在：等待下载完成通知过程中，不能做其他任务处理；</span><br></pre></td></tr></table></figure><p>2.同步非阻塞：小明提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条，看到 100% 就完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">同步体现在：等待下载完成通知；</span><br><span class="line">非阻塞体现在：等待下载完成通知过程中，去干别的任务了，只是时不时会瞄一眼进度条；【小明必须要在两个任务间切换，关注下载进度】</span><br></pre></td></tr></table></figure><p>3.异步阻塞：小明换了个有下载完成通知功能的软件，下载完成就“叮”一声。不过小明仍然一直等待“叮”的声音。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">异步体现在：下载完成“叮”一声通知；</span><br><span class="line">阻塞体现在：等待下载完成“叮”一声通知过程中，不能做其他任务处理；</span><br></pre></td></tr></table></figure><p>4.异步非阻塞：仍然是那个会“叮”一声的下载软件，小明提交下载任务后就去干别的，听到“叮”的一声就知道完成了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">异步体现在：下载完成“叮”一声通知；</span><br><span class="line">非阻塞体现在：等待下载完成“叮”一声通知过程中，去干别的任务了，只需要接收“叮”声通知即可；【软件处理下载任务，小明处理其他任务，不需关注进度，只需接收软件“叮”声通知，即可】</span><br></pre></td></tr></table></figure><p>同步和异步关注的是消息如何通知的机制，而阻塞和非阻塞关注的则是等待消息通知时的状态，这两个概念是理解同步、异步、阻塞、非阻塞的关键所在。</p><h1 id="死锁、饥饿、活锁"><a href="#死锁、饥饿、活锁" class="headerlink" title="死锁、饥饿、活锁"></a>死锁、饥饿、活锁</h1><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>死锁，是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p><p>例如，线程A已经获取资源R1，线程B已经获取资源R2，之后线程A尝试获取资源R2，这个时候因为资源R2已经被线程B获得了，所以线程A只能阻塞直到线程B释放资源R2。另一方面，线程B在已经获得资源R2的前提下尝试获取由线程A持有的资源R1，那么由于资源R1已经被线程A持有了，那么线程B只能被阻塞直到线程A释放资源R1。这样线程A和线程B都在等待对方持有的资源，就造成了死锁。</p><h3 id="死锁的四个条件"><a href="#死锁的四个条件" class="headerlink" title="死锁的四个条件"></a>死锁的四个条件</h3><p>1.互斥条件：线程使用的资源必须至少有一个是不能共享的（至少有锁）；<br>2.请求与保持条件：至少有一个线程必须持有一个资源并且正在等待获取一个当前被其它线程持有的资源（至少两个线程持有不同锁，又在等待对方持有锁）；<br>3.非剥夺条件：分配资源不能从相应的线程中被强制剥夺（不能强行获取被其他线程持有锁）；<br>4.循环等待条件：第一个线程等待其它线程，后者又在等待第一个线程（线程A等线程B；线程B等线程C;…;线程N等线程A。如此形成环路）。</p><h3 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h3><p>1.尽可能减少锁的范围，如在Java中尽量使用同步代码块而不使用同步方法；<br>2.尽量不编写在同一时刻获取多个锁的代码，因为在一个线程持有多个资源的时候很容易发生死锁；<br>3.根据情况将过大范围的锁进行切分，让每个锁的作用范围减小，从而降低死锁发生的概率。这以原则的典型应用是ConcurrentHashMap的锁分段技术。</p><h2 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h2><p>饥饿是指某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。<br>产生这种情况的原因是多种的，可能是它的线程优先级太低，而高优先级的线程不抢占它需要的资源，导致低优先级线程无法工作。也可能是某个线程一直占着关键资源不放，导致其他需要这个资源的线程无法正常执行。</p><h2 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h2><p>活锁指的是线程不断重复执行相同的操作，但每次操作的结果都是失败的。尽管这个问题不会阻塞线程，但是程序也无法继续执行。<br>举个现实生活中的例子，一条狭窄的道路，男子A和女子B迎面相遇了，缘分使然，A绅士的想让出道路让B先过，这时B也保持良好的淑女形象想让出道路让A先过，导致两人都避让了；两人尴尬一笑，之后A想着B既然让了，就准备先过，巧的是，这时B心里也想着，A既然让了，不如先过，两人又撞上了；然后又开始礼貌性的相互避让，避让之后各自又想先走结果又撞上了，结果两人都没过去。这种情况就是活锁。<br>线程都秉承着”谦让”的原则，主动将资源释放给他人使用，那么就会出现资源不断在两个线程之间跳动，而没有一个线程可以同时拿到所有资源而正常执行。<br>活锁通常发生在处理事务消息的应用程序中，如果不能成功处理这个事务那么事务将回滚整个操作。解决活锁的办法是在每次重复执行的时候引入随机机制，这样由于出现的可能性不同使得程序可以继续执行其他的任务。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本文参考众多文章总计而成，这里参考太多，所以只列举比较重要的几篇文章。<br><a href="http://www.androidchina.net/2987.html" target="_blank" rel="noopener">Java多线程和并发性知识点总结</a><br><a href="https://www.cnblogs.com/study-everyday/p/6856807.html" target="_blank" rel="noopener">并发编程的几个概念</a><br><a href="https://www.jianshu.com/p/aed6067eeac9" target="_blank" rel="noopener">聊聊同步、异步、阻塞与非阻塞</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;最近还是一直在准备面试这块的内容，大多数互联网公司面试，避免不了的会问到并发这块的内容，所以，准备写几篇Blog来总结一下Java并发方面知
      
    
    </summary>
    
      <category term="并发" scheme="http://nastublog.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="概念" scheme="http://nastublog.com/tags/%E6%A6%82%E5%BF%B5/"/>
    
      <category term="并发" scheme="http://nastublog.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>开发也要懂点算法-冒泡排序</title>
    <link href="http://nastublog.com/2018/08/01/%E5%BC%80%E5%8F%91%E4%B9%9F%E8%A6%81%E6%87%82%E7%82%B9%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://nastublog.com/2018/08/01/开发也要懂点算法-冒泡排序/</id>
    <published>2018-08-01T02:23:14.000Z</published>
    <updated>2018-08-04T03:30:02.404Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="算法" scheme="http://nastublog.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://nastublog.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>面试总结-追致科技</title>
    <link href="http://nastublog.com/2018/07/29/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-%E8%BF%BD%E8%87%B4%E7%A7%91%E6%8A%80/"/>
    <id>http://nastublog.com/2018/07/29/面试总结-追致科技/</id>
    <published>2018-07-29T13:49:15.000Z</published>
    <updated>2018-08-04T03:23:20.641Z</updated>
    
    <content type="html"><![CDATA[<p>本周末又华丽丽的跑去杭州了，面的是一家做电商领域的小公司，叫追致科技。<br><br>估计面试的是他们的老大吧，人还不错，约在星巴克面试的，还帮点了一份咖啡，好感度加分，然后和我讲他也是技术出身，所以对于技术比较重视，整个面试下来像是朋友之间谈话交流一般，没有过多的涉及到技术的问题，主要是问平时都喜欢看哪些书，通过看什么学习，然后有什么看法，中间穿插着项目和一些技术上的问题，还有自己对现在这份工作的感受，整体感觉还不错。<br><br>主要问的题目也就是根据简历上来，估计是看到我简历上写了一些前端的技术，先是问了Ajax是一个什么样的技术，然后问了jQuery选择方法和选择器，然后html、css、js分别承担了什么样的职责？因为我对于前端也不怎么熟悉，主要粗略的回答了一下，jQuery的选择器也就了解几个简单的选择器，对于组合选择器也是不太了解，之后可以熟悉一下。<br>然后就是问了数据库的问题，having一般用在什么时候，说说你对sql调优的理解，然后就是数据库索引的原理，这边sql调优刚刚有看过，po个链接在这吧。<br><br><a href="http://www.jfox.info/SQL-you-hua.html" target="_blank" rel="noopener">SQL优化</a><br></p><p>我主要也就是讲了不要随便使用select *以及不要随便使用会放弃索引而采取全表扫描的关键字，比如 in or，以及在经常需要排序的字段上添加索引这样的方法，这方面还是要多多看文章实践一下。<br><br>至于索引的原理，大概也就是停留在知道其是用B+树和变种B+树实现，通过这样的一个数据结构能够更快的定位到需要的位置这样的概念，之后有时间估计也会去学习一下B+树的数据结构。<br>然后Java的话问了一下Java8的新特性，以及你理解的函数式编程，他和面向对象编程有说么区别，这里我没有回答清楚，面试官给出了说法，主要就是函数式编程数据是不可改变的，之后准备去了解一下。<br>然后本次面试主要的大头也就是对之前笔试题做一个重构，笔试题虽然简单，但是他想考察的主要是一个人的设计能力和面向对象思想，这点估计是他比较看重的，这里po一下笔试题和我的第一版程序吧。<br><br>笔试题我也就记得住大概，一个平台，左下角定义是(0,0),输入右上角的最大坐标，然后输入一个漫步车的x,y坐标以及方向W、E、S、N，然后输入一串移动指令，L表示漫步车方向左转90°，R表示漫步车方向右转90°，M表示漫步车移动朝当前方向移动一格，输入指令后，显示出当前漫步车的位置。<br><br>大概就是这样吧，po一下我的第一版代码，可能有拙劣之处:<br><br>这是定义的漫步车对象:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 漫游车</span><br><span class="line"> * @Date: Created in 12:17 2018/7/19</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class RangeRovers &#123;</span><br><span class="line"></span><br><span class="line">    private int x; // 漫游车x坐标</span><br><span class="line"></span><br><span class="line">    private int y; // 漫游车y坐标</span><br><span class="line"></span><br><span class="line">    private Position position;</span><br><span class="line"></span><br><span class="line">    public int getX() &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setX(int x) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getY() &#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setY(int y) &#123;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Position getPosition() &#123;</span><br><span class="line">        return position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPosition(Position position) &#123;</span><br><span class="line">        this.position = position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RangeRovers(int x, int y, String position) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.position = Position.valueOf(position);</span><br><span class="line">        &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">            System.out.println(&quot;初始化方向错误，请输入正确方向代码&quot;);</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;RangeRovers&#123;&quot; +</span><br><span class="line">                &quot;x=&quot; + x +</span><br><span class="line">                &quot;, y=&quot; + y +</span><br><span class="line">                &quot;, position=&quot; + position +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为方向是定义好的常量，我们采取枚举的模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 方向</span><br><span class="line"> * @Date: Created in 12:16 2018/7/19</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public enum Position &#123;</span><br><span class="line">    E,</span><br><span class="line">    S,</span><br><span class="line">    W,</span><br><span class="line">    N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是定义的平台的对象，因为平台涉及到最大X、Y值和最小X、Y值，当漫步车移动到临界时，便无法再次移动。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 平台</span><br><span class="line"> * @Date: Created in 12:28 2018/7/19</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class PlatForm &#123;</span><br><span class="line"></span><br><span class="line">    private final int minX = 0; // 左下角横坐标</span><br><span class="line"></span><br><span class="line">    private final int minY = 0; // 左下角纵坐标</span><br><span class="line"></span><br><span class="line">    private int maxX; // 右上角横坐标</span><br><span class="line"></span><br><span class="line">    private int maxY; // 右上角纵坐标</span><br><span class="line"></span><br><span class="line">    public int getMinX() &#123;</span><br><span class="line">        return minX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getMinY() &#123;</span><br><span class="line">        return minY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getMaxX() &#123;</span><br><span class="line">        return maxX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMaxX(int maxX) &#123;</span><br><span class="line">        this.maxX = maxX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getMaxY() &#123;</span><br><span class="line">        return maxY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMaxY(int maxY) &#123;</span><br><span class="line">        this.maxY = maxY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PlatForm(int maxX, int maxY) &#123;</span><br><span class="line">        this.maxX = maxX;</span><br><span class="line">        this.maxY = maxY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;PlatForm&#123;&quot; +</span><br><span class="line">                &quot;minX=&quot; + minX +</span><br><span class="line">                &quot;, minY=&quot; + minY +</span><br><span class="line">                &quot;, maxX=&quot; + maxX +</span><br><span class="line">                &quot;, maxY=&quot; + maxY +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义了一个漫游车移动方法的接口(这里就是设计的不合理之处了，怎么不合理，之后会提到)。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 漫游者移动接口</span><br><span class="line"> * @Date: Created in 12:20 2018/7/19</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public interface IRangeRoversMove &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  漫步车移动方法</span><br><span class="line">     * @param rangeRovers 漫步车对象</span><br><span class="line">     * @param platForm 平台对象</span><br><span class="line">     * @param moveCommand 移动指令</span><br><span class="line">     */</span><br><span class="line">    void rangeRoversMove(RangeRovers rangeRovers, PlatForm platForm, String moveCommand);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义了实现漫游车移动接口的漫游车指令接收器，里面实现了漫步车移动的通用方法，并设置了两个private方法，分别是漫步车根据不同指令做出的改变方向的方法和移动方法。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 漫步车指令接收器</span><br><span class="line"> * @Date: Created in 12:46 2018/7/19</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class RangeRoversCommandReceiver implements IRangeRoversMove &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void rangeRoversMove(RangeRovers rangeRovers, PlatForm platForm, String moveCommand) &#123;</span><br><span class="line"></span><br><span class="line">        char[] moveCommandArray = moveCommand.toCharArray();</span><br><span class="line"></span><br><span class="line">        for (int i = 0;i&lt;moveCommandArray.length;i++) &#123;</span><br><span class="line">            char moveCommandChar = moveCommandArray[i];</span><br><span class="line">            if (&quot;M&quot;.equalsIgnoreCase(String.valueOf(moveCommandChar))) &#123;</span><br><span class="line">                this.stepMove(rangeRovers, platForm, moveCommand.toString());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.postionChange(rangeRovers, String.valueOf(moveCommandChar));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 方向改变函数</span><br><span class="line">     *</span><br><span class="line">     * @param rangeRovers          漫步车对象</span><br><span class="line">     * @param changePositonCommand 方向改变命令</span><br><span class="line">     */</span><br><span class="line">    private void postionChange(RangeRovers rangeRovers, String changePositonCommand) &#123;</span><br><span class="line">        if (&quot;L&quot;.equalsIgnoreCase(changePositonCommand)) &#123;</span><br><span class="line">            switch (rangeRovers.getPosition()) &#123;</span><br><span class="line">                case E:</span><br><span class="line">                    rangeRovers.setPosition(Position.N);</span><br><span class="line">                    break;</span><br><span class="line">                case N:</span><br><span class="line">                    rangeRovers.setPosition(Position.W);</span><br><span class="line">                    break;</span><br><span class="line">                case W:</span><br><span class="line">                    rangeRovers.setPosition(Position.S);</span><br><span class="line">                    break;</span><br><span class="line">                case S:</span><br><span class="line">                    rangeRovers.setPosition(Position.E);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (&quot;R&quot;.equalsIgnoreCase(changePositonCommand)) &#123;</span><br><span class="line">            switch (rangeRovers.getPosition()) &#123;</span><br><span class="line">                case E:</span><br><span class="line">                    rangeRovers.setPosition(Position.S);</span><br><span class="line">                    break;</span><br><span class="line">                case S:</span><br><span class="line">                    rangeRovers.setPosition(Position.W);</span><br><span class="line">                    break;</span><br><span class="line">                case W:</span><br><span class="line">                    rangeRovers.setPosition(Position.N);</span><br><span class="line">                    break;</span><br><span class="line">                case N:</span><br><span class="line">                    rangeRovers.setPosition(Position.E);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 漫步车移动方法</span><br><span class="line">     *</span><br><span class="line">     * @param rangeRovers     漫步车对象</span><br><span class="line">     * @param platForm        平台对象</span><br><span class="line">     * @param stepMoveCommand 移动指令</span><br><span class="line">     */</span><br><span class="line">    private void stepMove(RangeRovers rangeRovers, PlatForm platForm, String stepMoveCommand) &#123;</span><br><span class="line">        switch (rangeRovers.getPosition()) &#123;</span><br><span class="line">            case S:</span><br><span class="line">                if (rangeRovers.getY() &gt; platForm.getMinY()) &#123;</span><br><span class="line">                    rangeRovers.setY(rangeRovers.getY()-1);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case N:</span><br><span class="line">                if (rangeRovers.getY() &lt; platForm.getMaxY()) &#123;</span><br><span class="line">                    rangeRovers.setY(rangeRovers.getY()+1);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case W:</span><br><span class="line">                if (rangeRovers.getX() &gt; platForm.getMinX()) &#123;</span><br><span class="line">                    rangeRovers.setX(rangeRovers.getX()-1);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case E:</span><br><span class="line">                if (rangeRovers.getX() &lt; platForm.getMaxX()) &#123;</span><br><span class="line">                    rangeRovers.setX(rangeRovers.getX()+1);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写了一个Client测试类来测试结果:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;请输入平台右上角坐标&quot;);</span><br><span class="line"></span><br><span class="line">        int maxX = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        int maxY = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        PlatForm platForm = new PlatForm(maxX, maxY);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;初始化探索平台完成,信息是:&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(platForm.toString());</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.println(&quot;请输入漫步车初始坐标和初始方向&quot;);</span><br><span class="line"></span><br><span class="line">            int rangeRoversX = sc.nextInt();</span><br><span class="line"></span><br><span class="line">            int rangeRoversY = sc.nextInt();</span><br><span class="line"></span><br><span class="line">            String rangeRoversPostion = sc.nextLine().trim();</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;初始化漫步车&quot;);</span><br><span class="line"></span><br><span class="line">            RangeRovers rangeRovers = new RangeRovers(rangeRoversX, rangeRoversY, rangeRoversPostion);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;初始化漫步车完成,信息是:&quot;);</span><br><span class="line"></span><br><span class="line">            System.out.println(rangeRovers.toString());</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;请输入移动指令:&quot;);</span><br><span class="line"></span><br><span class="line">            String moveCommand = sc.nextLine().trim();</span><br><span class="line"></span><br><span class="line">            RangeRoversCommandReceiver rangeRoversCommandReceiver = new RangeRoversCommandReceiver();</span><br><span class="line"></span><br><span class="line">            rangeRoversCommandReceiver.rangeRoversMove(rangeRovers, platForm, moveCommand);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;当前漫步车信息&quot;);</span><br><span class="line"></span><br><span class="line">            System.out.println(rangeRovers.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行，具体结果如下<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">请输入平台右上角坐标</span><br><span class="line">5 5 </span><br><span class="line">初始化探索平台完成,信息是:</span><br><span class="line">PlatForm&#123;minX=0, minY=0, maxX=5, maxY=5&#125;</span><br><span class="line">请输入漫步车初始坐标和初始方向</span><br><span class="line">1 1 E</span><br><span class="line">初始化漫步车</span><br><span class="line">初始化漫步车完成,信息是:</span><br><span class="line">RangeRovers&#123;x=1, y=1, position=E&#125;</span><br><span class="line">请输入移动指令:</span><br><span class="line">LMMRMMLMRM</span><br><span class="line">当前漫步车信息</span><br><span class="line">RangeRovers&#123;x=4, y=4, position=E&#125;</span><br><span class="line">请输入漫步车初始坐标和初始方向</span><br></pre></td></tr></table></figure><p>面试官说，这段代码，仔细看了一下，好像封装了很多类，但是，其实并没有体现出面向对象的思想，为什么这么说呢?<br><br>第一，漫步车既然封装了一个对象，但这个对象，仅仅是涉及到了漫步车的初始定义，X轴坐标、Y轴坐标、初始方向，这样的做法是毫无意义的。我想了一下，说可以把漫步车封装成一个抽象类，将通用的移动方法定义为抽象方法，然后将改变方向的方法和移动方法放在了移动接口里，然后定义具体的漫步车继承抽象漫步车并实现接口，大概就是如下的代码。<br></p><p>先是一个抽象的漫步车：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 漫游车</span><br><span class="line"> * @Date: Created in 12:17 2018/7/19</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public abstract class AbstractRangeRover &#123;</span><br><span class="line"></span><br><span class="line">    private int x; // 漫游车x坐标</span><br><span class="line"></span><br><span class="line">    private int y; // 漫游车y坐标</span><br><span class="line"></span><br><span class="line">    private Position position;</span><br><span class="line"></span><br><span class="line">    public int getX() &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setX(int x) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getY() &#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setY(int y) &#123;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Position getPosition() &#123;</span><br><span class="line">        return position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPosition(Position position) &#123;</span><br><span class="line">        this.position = position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AbstractRangeRover(int x, int y, String position) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.position = Position.valueOf(position);</span><br><span class="line">        &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">            System.out.println(&quot;初始化方向错误，请输入正确方向代码&quot;);</span><br><span class="line">            System.exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;RangeRovers&#123;&quot; +</span><br><span class="line">                &quot;x=&quot; + x +</span><br><span class="line">                &quot;, y=&quot; + y +</span><br><span class="line">                &quot;, position=&quot; + position +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void rangeRoversMove(PlatForm platForm, String moveCommand);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后仍旧是漫步车移动接口<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 漫游车移动接口</span><br><span class="line"> * @Date: Created in 12:20 2018/7/19</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public interface IRangeRoversMove &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 漫步车改变方向方法</span><br><span class="line">     *</span><br><span class="line">     * @param changePositonCommand 移动指令</span><br><span class="line">     */</span><br><span class="line">    void postionChange(String changePositonCommand);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 漫步车移动方法</span><br><span class="line">     * @param platForm</span><br><span class="line">     */</span><br><span class="line">    void stepMove(PlatForm platForm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是具体的漫步车<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 具体漫步车</span><br><span class="line"> * @Date: Created in 12:46 2018/7/19</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class ConcreteRangeRover extends AbstractRangeRover implements IRangeRoversMove &#123;</span><br><span class="line"></span><br><span class="line">    public ConcreteRangeRover(int x,int y,String position)&#123;</span><br><span class="line">        super(x,y,position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void rangeRoversMove(PlatForm platForm, String moveCommand) &#123;</span><br><span class="line"></span><br><span class="line">        char[] moveCommandArray = moveCommand.toCharArray();</span><br><span class="line"></span><br><span class="line">        for (int i = 0;i&lt;moveCommandArray.length;i++) &#123;</span><br><span class="line">            char moveCommandChar = moveCommandArray[i];</span><br><span class="line">            if (&quot;M&quot;.equalsIgnoreCase(String.valueOf(moveCommandChar))) &#123;</span><br><span class="line">                this.stepMove( platForm);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.postionChange( String.valueOf(moveCommandChar));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 方向改变函数</span><br><span class="line">     * @param changePositonCommand 方向改变命令</span><br><span class="line">     */</span><br><span class="line">    public void postionChange(String changePositonCommand) &#123;</span><br><span class="line">        if (&quot;L&quot;.equalsIgnoreCase(changePositonCommand)) &#123;</span><br><span class="line">            switch (this.getPosition()) &#123;</span><br><span class="line">                case E:</span><br><span class="line">                    this.setPosition(Position.N);</span><br><span class="line">                    break;</span><br><span class="line">                case N:</span><br><span class="line">                    this.setPosition(Position.W);</span><br><span class="line">                    break;</span><br><span class="line">                case W:</span><br><span class="line">                    this.setPosition(Position.S);</span><br><span class="line">                    break;</span><br><span class="line">                case S:</span><br><span class="line">                    this.setPosition(Position.E);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (&quot;R&quot;.equalsIgnoreCase(changePositonCommand)) &#123;</span><br><span class="line">            switch (this.getPosition()) &#123;</span><br><span class="line">                case E:</span><br><span class="line">                    this.setPosition(Position.S);</span><br><span class="line">                    break;</span><br><span class="line">                case S:</span><br><span class="line">                    this.setPosition(Position.W);</span><br><span class="line">                    break;</span><br><span class="line">                case W:</span><br><span class="line">                    this.setPosition(Position.N);</span><br><span class="line">                    break;</span><br><span class="line">                case N:</span><br><span class="line">                    this.setPosition(Position.E);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 漫步车移动方法</span><br><span class="line">     * @param platForm        平台对象</span><br><span class="line">     */</span><br><span class="line">    public void stepMove(PlatForm platForm) &#123;</span><br><span class="line">        switch (this.getPosition()) &#123;</span><br><span class="line">            case S:</span><br><span class="line">                if (this.getY() &gt; platForm.getMinY()) &#123;</span><br><span class="line">                    this.setY(this.getY()-1);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case N:</span><br><span class="line">                if (this.getY() &lt; platForm.getMaxY()) &#123;</span><br><span class="line">                    this.setY(this.getY()+1);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case W:</span><br><span class="line">                if (this.getX() &gt; platForm.getMinX()) &#123;</span><br><span class="line">                    this.setX(this.getX()-1);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case E:</span><br><span class="line">                if (this.getX() &lt; platForm.getMaxX()) &#123;</span><br><span class="line">                    this.setX(this.getX()+1);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看似对上面代码进行的改造，可还是有不合理的地方：<br><br>第一点，改变方向和移动的方法访问域因为实现了接口，必须是public，这是不合理的，外部按道理只需要调用通用的移动方法就行了，所以并没有必要暴露具体的改变方向的方法和移动的方法给外部访问;<br><br>第二点，这道题的业务场景并不需要定义接口，接口是什么，是对行为的一种抽象，而此题，因为漫步车不仅有抽象的移动方法，还有他自己的属性和默认方法，所以并没有采用接口的设计，而是采用了抽象类，所以，只需要将所有的移动方法定义为抽象的即可。<br><br>第三点，定义漫步车也并没有抛出异常的必要(顺带这里问了一下Java异常的分类，以及RuntimeException和非RuntimeException得区别)。<br></p><p>基于以上几点，我又说了一下自己的思路，这里就不在po代码了，大致说一下吧，因为我们不需要将改变方向和移动的方法给外部访问，外部只需要调用通用的移动方法，传入指令，通用的方法会自动判断每一个指令应该调用什么方法，所以，我们在设计抽象方法的时候只需要将改变方向和移动的方法的访问域设为protected就行，因为面试官之后还有事情，我也还要赶回上海时，所以这大概就是我和面试官聊得最后的思路。<br><br>临走之前，面试官让我回去再优化优化这段逻辑，我思考了一下，这大概可以用到我最近刚看过的模板方法模式，通用的移动方法就是模板方法，并不需要在具体的类中去实现他，因为漫步车现在涉及的操作无非就是移动和改变方向，而之后需求变更，变更的可能会使指令所代表的移动的长度以及改变方向的方法，而对于整体的逻辑改动可能会较小，所以可以将通用的方法设计成模板方法写在抽象类里，也就是定义了一个操作算法的框架，而具体的方法延迟到子类里去执行，这大概就是模板方法模式。<br><br>这里还涉及到了指令的判断，于是我们可以在抽象类中再封装一个指令判断的默认方法，如果具体的指令判断有改变，则在子类中重写该方法，这个判断指令的方法可以称之为钩子方法。<br><br>这大概就是我的最终思路，下面看一下具体的代码实现。<br><br>抽象的漫步车<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 漫游车</span><br><span class="line"> * @Date: Created in 12:17 2018/7/19</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public abstract class AbstractRangeRover &#123;</span><br><span class="line"></span><br><span class="line">    private int x; // 漫游车x坐标</span><br><span class="line"></span><br><span class="line">    private int y; // 漫游车y坐标</span><br><span class="line"></span><br><span class="line">    private Position position;</span><br><span class="line"></span><br><span class="line">    public int getX() &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setX(int x) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getY() &#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setY(int y) &#123;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Position getPosition() &#123;</span><br><span class="line">        return position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPosition(Position position) &#123;</span><br><span class="line">        this.position = position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AbstractRangeRover(int x, int y, String position) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">        this.position = Position.valueOf(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;RangeRovers&#123;&quot; +</span><br><span class="line">                &quot;x=&quot; + x +</span><br><span class="line">                &quot;, y=&quot; + y +</span><br><span class="line">                &quot;, position=&quot; + position +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 漫步车移动模板方法</span><br><span class="line">     * @param platForm</span><br><span class="line">     * @param command</span><br><span class="line">     */</span><br><span class="line">    public  void rangeRoversMove(PlatForm platForm, String command)&#123;</span><br><span class="line">        char[] commandArray = command.toCharArray();</span><br><span class="line">        for (int i = 0;i&lt;commandArray.length;i++) &#123;</span><br><span class="line">            char commandChar = commandArray[i];</span><br><span class="line">            if (this.isStepMove(String.valueOf(commandChar))) &#123;</span><br><span class="line">                this.stepMove(platForm,String.valueOf(commandChar));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.postionChange(String.valueOf(commandChar));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected abstract void postionChange(String changePositonCommand);</span><br><span class="line"></span><br><span class="line">    protected abstract void stepMove(PlatForm platForm, String moveCommand);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 钩子方法，默认M代表移动，其他代表改变方向，如果具体的构造车不同，可以重写钩子方法</span><br><span class="line">     * @param command</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    protected boolean isStepMove(String command) &#123;</span><br><span class="line">        if (&quot;M&quot;.equalsIgnoreCase(command)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中，通用的模板方法封装了具体的算法思路，也就是通过钩子方法确定是调用改变方向的方法还是移动的方法,然后抛出异常没有意义(这里建立在ACM的思想上，输入的数据都是合法的，如果可能存在不合法的数据，建议是封装初始化方法，初始化失败后重新调用并给出提示)<br></p><p>然后是具体的漫步车<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 具体漫步车</span><br><span class="line"> * @Date: Created in 12:46 2018/7/19</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class ConcreteRangeRover extends AbstractRangeRover &#123;</span><br><span class="line"></span><br><span class="line">    public ConcreteRangeRover(int x,int y,String position)&#123;</span><br><span class="line">        super(x,y,position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 方向改变函数</span><br><span class="line">     * @param changePositonCommand 方向改变命令</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void postionChange(String changePositonCommand) &#123;</span><br><span class="line">        if (&quot;L&quot;.equalsIgnoreCase(changePositonCommand)) &#123;</span><br><span class="line">            switch (this.getPosition()) &#123;</span><br><span class="line">                case E:</span><br><span class="line">                    this.setPosition(Position.N);</span><br><span class="line">                    break;</span><br><span class="line">                case N:</span><br><span class="line">                    this.setPosition(Position.W);</span><br><span class="line">                    break;</span><br><span class="line">                case W:</span><br><span class="line">                    this.setPosition(Position.S);</span><br><span class="line">                    break;</span><br><span class="line">                case S:</span><br><span class="line">                    this.setPosition(Position.E);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (&quot;R&quot;.equalsIgnoreCase(changePositonCommand)) &#123;</span><br><span class="line">            switch (this.getPosition()) &#123;</span><br><span class="line">                case E:</span><br><span class="line">                    this.setPosition(Position.S);</span><br><span class="line">                    break;</span><br><span class="line">                case S:</span><br><span class="line">                    this.setPosition(Position.W);</span><br><span class="line">                    break;</span><br><span class="line">                case W:</span><br><span class="line">                    this.setPosition(Position.N);</span><br><span class="line">                    break;</span><br><span class="line">                case N:</span><br><span class="line">                    this.setPosition(Position.E);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 漫步车移动方法</span><br><span class="line">     * @param platForm</span><br><span class="line">     * @param moveCommand(这个参数还是有必要的我觉得，因为以后可能对移动的命令有所扩展，既然是针对命令移动，</span><br><span class="line">     * 我认为传入命令参数是有必要的，虽然现在的业务移动逻辑只有M一种，不保证需求变更后会不会增加)</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line"></span><br><span class="line">    protected void stepMove(PlatForm platForm,String moveCommand) &#123;</span><br><span class="line">        switch (this.getPosition()) &#123;</span><br><span class="line">            case S:</span><br><span class="line">                if (this.getY() &gt; platForm.getMinY()) &#123;</span><br><span class="line">                    this.setY(this.getY()-1);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case N:</span><br><span class="line">                if (this.getY() &lt; platForm.getMaxY()) &#123;</span><br><span class="line">                    this.setY(this.getY()+1);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case W:</span><br><span class="line">                if (this.getX() &gt; platForm.getMinX()) &#123;</span><br><span class="line">                    this.setX(this.getX()-1);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case E:</span><br><span class="line">                if (this.getX() &lt; platForm.getMaxX()) &#123;</span><br><span class="line">                    this.setX(this.getX()+1);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象漫步车里定义的改变方向方法和移动方法都延迟到了具体类里实现，这就是模板方式的好处，在不改变原有算法的结构的情况下，可以重定义该算法的某些特定步骤。<br></p><p>最后还是测试类测试一下<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Scanner sc = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;请输入平台右上角坐标&quot;);</span><br><span class="line"></span><br><span class="line">        int maxX = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        int maxY = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        PlatForm platForm = new PlatForm(maxX, maxY);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;初始化探索平台完成,信息是:&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(platForm.toString());</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.println(&quot;请输入漫步车初始坐标和初始方向&quot;);</span><br><span class="line"></span><br><span class="line">            int rangeRoversX = sc.nextInt();</span><br><span class="line"></span><br><span class="line">            int rangeRoversY = sc.nextInt();</span><br><span class="line"></span><br><span class="line">            String rangeRoversPostion = sc.nextLine().trim();</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;初始化漫步车&quot;);</span><br><span class="line"></span><br><span class="line">            ConcreteRangeRover concreteRangeRover = new ConcreteRangeRover(rangeRoversX, rangeRoversY, rangeRoversPostion);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;初始化漫步车完成,信息是:&quot;);</span><br><span class="line"></span><br><span class="line">            System.out.println(concreteRangeRover.toString());</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;请输入移动指令:&quot;);</span><br><span class="line"></span><br><span class="line">            String moveCommand = sc.nextLine().trim();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            concreteRangeRover.rangeRoversMove(platForm, moveCommand);</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;当前漫步车信息&quot;);</span><br><span class="line"></span><br><span class="line">            System.out.println(concreteRangeRover.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">请输入平台右上角坐标</span><br><span class="line">5 5</span><br><span class="line">初始化探索平台完成,信息是:</span><br><span class="line">PlatForm&#123;minX=0, minY=0, maxX=5, maxY=5&#125;</span><br><span class="line">请输入漫步车初始坐标和初始方向</span><br><span class="line">1 1 E</span><br><span class="line">初始化漫步车</span><br><span class="line">初始化漫步车完成,信息是:</span><br><span class="line">RangeRovers&#123;x=1, y=1, position=E&#125;</span><br><span class="line">请输入移动指令:</span><br><span class="line">LMMRMMLMRM</span><br><span class="line">当前漫步车信息</span><br><span class="line">RangeRovers&#123;x=4, y=4, position=E&#125;</span><br><span class="line">请输入漫步车初始坐标和初始方向</span><br></pre></td></tr></table></figure></p><p>这道题目虽然简单，可细细想起来，还是有很多值得回味的地方的，所以说，平时编写代码的时候，多思考多动脑，或许会有不一样的收获，这里用到了设计模式里的模板方法模式，之后也会写一篇博客总结一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本周末又华丽丽的跑去杭州了，面的是一家做电商领域的小公司，叫追致科技。&lt;br&gt;&lt;br&gt;估计面试的是他们的老大吧，人还不错，约在星巴克面试的，还帮点了一份咖啡，好感度加分，然后和我讲他也是技术出身，所以对于技术比较重视，整个面试下来像是朋友之间谈话交流一般，没有过多的涉及到技
      
    
    </summary>
    
      <category term="随笔" scheme="http://nastublog.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="面试" scheme="http://nastublog.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试总结-有赞电面</title>
    <link href="http://nastublog.com/2018/07/28/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-%E6%9C%89%E8%B5%9E%E7%94%B5%E9%9D%A2/"/>
    <id>http://nastublog.com/2018/07/28/面试总结-有赞电面/</id>
    <published>2018-07-28T07:00:21.000Z</published>
    <updated>2018-08-04T03:26:15.980Z</updated>
    
    <content type="html"><![CDATA[<p>昨晚接到了有赞的电话面试，唉，又是被虐的一次经历。整体上来说，自我感觉Java基础方面经过一星期的突击，还算有点成效，但是一涉及到Spring框架的方面，就一无所知了，面试完了，照例写一个小总结吧。<br>大概是6点半左右接到的面试电话，按照惯例的3分钟自我介绍，介绍完了后面试官就向我介绍了他们部门的情况，主要是做OA的，说是业务结构比较复杂，还有不会涉及到高并发，因为我在介绍的时候说过自己想接触高并发这一块，然后就开始面试过程了。<br>主要的话还是分为框架部分和Java基础部分网络顺带也提了一下，就根据自己的印象写一写问到的题目吧。<br>1.Spring Scope域有哪几种，默认是什么，分别代表了什么?（我就知道一个Singleton，而且模模糊糊的）<br>2.Spring bean创建后就会一直存在么，如果不是，什么时候销毁?<br>3.Spring的拦截器有了解过么，在什么地方使用过?(我就大致说了一下Spring的拦截器也是基于AOP实现的，然后我只使用过Mybatis的拦截器，而且也说不出个所以然来，只知道大致的实现方法)<br>4.Spring Aop了解过么?Advice有哪几种类型<br>5.Aop是基于什么设计模式实现的?动态代理有哪几种?<br>6.ArrayList和LinkedList的区别?<br>7.Arrays.asList()了解过么?这样创建List和new有什么不同?创建出来的List能进行add和remove操作么?(我说Array.asList()是抽象工厂的方法，也不知道对不对)<br>8.HashMap的底层原理?(这个最近刚好看过，就balabala说了一大堆，最尴尬的是，Entry被我说成了Node)<br>9.HashMap的负载因子为什么设置成0.75，设成1能存更多么?<br>10.HashMap index冲突时采用的是头插还是尾插，为什么?<br>总的来说，面试结果不尽如人意，框架部分模模糊糊，想回答回答不出来，只能大概描述一下，而且还不知道对不对，Java基础部分，涉及到为什么这样设计的时候，也回答的模棱两可，感觉自己就是为了应付面试去看这些原理，并没有好好想想为什么这么设计，借用面试官的一句话来说，感觉你这些东西好像都用过，但是说起来的时候，原理都不太了解。<br>借由这两次面试，也思考了一下自己未来的职业发展方向，暂时也比较模糊，但是，本身对于J2EE的开发不太感兴趣，可能还是想往更深的道路走吧，所以打算了一下，准备以后更多的花时间在Java基础上，比如源码的研究，然后适当的看看算法和设计模式，尽量保证一周看一种设计模式和算法吧，跳槽完成后也准备去POJ上刷刷算法题了，反正，先做准备吧，指不定啥时候就用上了呢，哈哈哈哈，fighting 少年。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨晚接到了有赞的电话面试，唉，又是被虐的一次经历。整体上来说，自我感觉Java基础方面经过一星期的突击，还算有点成效，但是一涉及到Spring框架的方面，就一无所知了，面试完了，照例写一个小总结吧。&lt;br&gt;大概是6点半左右接到的面试电话，按照惯例的3分钟自我介绍，介绍完了后
      
    
    </summary>
    
      <category term="随笔" scheme="http://nastublog.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="面试" scheme="http://nastublog.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试总结-招银网络科技</title>
    <link href="http://nastublog.com/2018/07/23/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93-%E6%8B%9B%E9%93%B6%E7%BD%91%E7%BB%9C%E7%A7%91%E6%8A%80/"/>
    <id>http://nastublog.com/2018/07/23/面试总结-招银网络科技/</id>
    <published>2018-07-23T15:27:41.000Z</published>
    <updated>2018-08-04T03:30:18.462Z</updated>
    
    <content type="html"><![CDATA[<p>今天去杭州招银笔面试回来，真的是累的不行，天气又热，人生地不熟的，上午百世的面试还被面试官”愉快的”放了鸽子，真的是祸不单行。<br>    下午早早地到了面试地点，发现超多招银的人在排队，我开始还以为有啥活动，或者是领取什么物品，结果一问，全是在排队等电梯，我的天，和游乐场有的一拼。<br>    在面试地点，见到一个年轻的小哥哥，问了一下，竟然已经做IOS做了三年了，而且实际工作年龄还不止三年，真的是人不可貌相呢。小哥哥人真好，我笔不知道丢哪去了，他还送了支笔给我，希望这么好的人能够面试通过啦。<br>    招银科技笔试和第一次面试是穿插进行的，笔试简直是一塌糊涂，很多概念性的问题和看过的问题都已经忘了，一共30道单选题，60道填空题和4道大题，大概记一下大题吧，算是给自己长点记性，留个纪念。<br>    第一题，就是最大公约数和最小公倍数的填空实现，没啥难度，毕竟大学做了1年的ACM。<br>    第二题，问了一下Java IO类设计采用了什么模式，也就是装饰器模式，然后简单介绍了一下，我就拿奶茶店的例子介绍了一下，然后让画UML类图，这就很尴尬啦，我的博客还没写到装饰器模式，之前也只是粗略的看了一下，并没有准确的记住，看样子UML图还要加强。<br>    第三题，一道简单的SQL题，千不该万不该，这道题竟然出了岔子，最后一个取最大值的问题，我竟然把max函数写在了where里面，看样子，真的离了编辑器写代码都是错啊，引以为戒引以为戒，顺带一提，填空里的synchronized我竟然都拼错了，ide的自动补全功能真的是惯坏了我哦。<br>    第四题，用你的思路实现队列。并用伪代码描述，哈哈哈，我就知道队列的存储结构是用数组实现的，具体实现思路嘛，就凭空乱想。因为队列是一个先进先出的结构，所以我就大概说了想法就是永远只取数组的最后一个数。大概就是定义了一个静态变量，用于表述当前的队列里的元素个数，然后定义了一个数组用于存储插入进来的元素。然后判断了一下如果当前元素个数是0，就会抛出异常，写的是伪代码，但是写的十分杂乱，现在想起来，的确是有挺多问题的。改天可以写一篇博客，专门描述一下栈和队列的实现方法。<br>    面试的话，穿插在笔试中间进行的，上来也就大概自我介绍了一下，然后面试官让我介绍一下自己在项目中做过了什么，什么是最重要的最有价值的，我大概就说了一下中交租赁系统里面的工作流模块，和我基于原生的activiti引擎如何二开新功能的，因为本身一面试就紧张，结结巴巴的，面试官十分和善，让我别紧张，项目说的中规中矩吧，感觉没有把自己的突出点突出出来，还是要针对自己的项目多一下。<br>    然后就问了一下Java基础，很丢脸，上来第一题我就被问住了，问了我Java引用的类型，我一开始还以为是强弱引用，可是强弱引用的概念在我脑子里十分模糊，所以我没会打上来，这个还是挺让人难受的，引以为戒吧，其实Java的引用类型就是分为值类型和引用类型，值类型就是Java的8大基本类型，而引用类型,是指除了基本的变量类型之外的所有类型。<br>    然后闻了一下JVM类加载的过程，我大概就把之前在博客和公众号看到的过程说了一下，类加载的7个过程，加载-验证-准备-解析-初始化-使用-卸载，说的马马虎虎吧，面试官也没深入去问，JVM在面试中还是会被经常问到的，需要继续加强吧。<br>    然后问了一下设计模式，正好我最近在看这一类的书，比较Lucky，让我说了两种设计模式，我说了单例和代理，然后让我分别对两种设计模式进行了介绍，我就说了一下单例模式的几种实现方法：懒汉、饿汉、加锁的懒汉、双重检查和枚举，在这里面试官问我为什么采取双重检查的机制，我回答不采取这个依旧会产生线程不安全的问题，面试官问了双重检查就能避免这个问题么，我说是的，他说最好回去再看一下，然后我看了一下，双重检查依旧会有线程不安全的问题存在，原因是因为指令重排，后续也需要在巩固一下，然后又说了代理模式，也就简单的提了一下静态代理和动态代理的两种实现方法，基于JDK和InvacationHandler接口和Proxy实现的动态代理和cglib的动态代理，然后让画了UML图，结果忘了画出Proxy也是实现Subject接口的，明明刚刚才看过，实在不应该啊。<br>    最后问了fail-fast和fail-safe机制，这个实在是没有了解过了，看了一下，貌似是和集合并发有关的，回来之后要多看看。<br>面的，这次跳槽估计是一次漫长的旅程，也希望找到心仪的工作吧。<br>    总结一下吧，明显这次笔试面试准备的不够充分，这也是因为工作一年来，前半年都没想着要好好看书，等到真正要找工作了，才发现自己的基础十分薄弱，这次面试也算给了自己一个教训吧，真的是要下点功夫好好看书了。不过得到了喜欢的女孩子的鼓励，还算是比较开心的，为了不辜负她的期待，努力吧，少年。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天去杭州招银笔面试回来，真的是累的不行，天气又热，人生地不熟的，上午百世的面试还被面试官”愉快的”放了鸽子，真的是祸不单行。&lt;br&gt;    下午早早地到了面试地点，发现超多招银的人在排队，我开始还以为有啥活动，或者是领取什么物品，结果一问，全是在排队等电梯，我的天，和游乐
      
    
    </summary>
    
      <category term="随笔" scheme="http://nastublog.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="面试" scheme="http://nastublog.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-代理模式(Proxy)</title>
    <link href="http://nastublog.com/2018/07/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-Proxy/"/>
    <id>http://nastublog.com/2018/07/21/设计模式-代理模式-Proxy/</id>
    <published>2018-07-21T05:56:58.000Z</published>
    <updated>2018-07-31T15:41:32.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近在准备跳槽的面试，然后在看Spring框架原理的时候，顺便了解一下AOP的设计模式-代理模式。<br><br>其实，代理模式在我们生活中非常常见，比如，玩游戏的时候不想手动练级，于是我们会去网上找代练帮我们完成练级的过程，这就是代理。再比如打官司的时候请律师，这也是代理，这样子我们只用准备我们的证词发言，而对于那些事件的调查和分析我们都全权交给了律师来做。</p><h1 id="代理模式的定义"><a href="#代理模式的定义" class="headerlink" title="代理模式的定义"></a>代理模式的定义</h1><p>代理模式也被叫做委托模式，是一个日常使用率很高的模式，其定义如下：<br>为其他对象提供一种代理控制这个对象的访问。</p><p>代理模式的UML图如下:</p><p><img src="/2018/07/21/设计模式-代理模式-Proxy/代理模式.png" alt="代理模式"></p><p>一般的代理模式有着三个角色，下面对这三个角色进行一个简单的介绍:<br><br>1.Subject 抽象主题角色<br>它可以是抽象类也可以是接口，是一个最普通的业务定义类型，比如在玩游戏这个例子中，它代表着游戏玩家这一群体。</p><p>2.RealSubject 具体主题角色<br>它其实就是被代理的角色，它继承或者实现了抽象主题角色，比如我请了一个工作室帮我代练，那么我的游戏角色<br>就是这个被代理的角色。</p><p>3.Proxy 代理主题角色<br>也叫做委托类、代理类。它负责处理对真实角色的应用，内部含有了RealSubject的引用，然后调用了具体角色里对抽象角色的实现方法，并且可以在加入自己的逻辑，实现一些预处理和善后工作。在玩游戏的这个例子里，对应的就是游戏代练工作室。</p><p>这就是代理模式的三个具体类。</p><h1 id="代理模式的应用"><a href="#代理模式的应用" class="headerlink" title="代理模式的应用"></a>代理模式的应用</h1><h2 id="代理模式的主要作用"><a href="#代理模式的主要作用" class="headerlink" title="代理模式的主要作用"></a>代理模式的主要作用</h2><p>通过引入代理对象来间接地去访问目标对象。</p><h2 id="代理模式的优点"><a href="#代理模式的优点" class="headerlink" title="代理模式的优点"></a>代理模式的优点</h2><p>1.划分了具体的职责<br>RealSubject只需要实现具体的业务逻辑，不需要对其他的逻辑进行操作，这些操作全权交给代理类去实现，后期可以通过代理类的预处理和善后处理的方法完成一件事务。<br>2.高扩展性<br>业务逻辑随时随地都会发生变化，但是，无论其怎么变化，代理类都不需要进行修改。<br>3.智能化<br>具体体现在动态代理上，之后会提到。</p><h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><p>防止直接访问目标目标对象给系统带来的不必要的复杂性。</p><h1 id="代理模式的具体实现"><a href="#代理模式的具体实现" class="headerlink" title="代理模式的具体实现"></a>代理模式的具体实现</h1><p>这里借用了玩游戏的例子，来看一下最简单的代理模式的实现：</p><p>先定义一个抽象的玩家接口，也就是上面上的Subject角色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package Proxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 玩家接口</span><br><span class="line"></span><br><span class="line"> * @Date: Created in 00:11 2018/7/20</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public interface IGamePlayer &#123;</span><br><span class="line"></span><br><span class="line">    public void login(String user, String password);</span><br><span class="line"></span><br><span class="line">    public void killBoss();</span><br><span class="line"></span><br><span class="line">    public void upgrade();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是具体玩家实现类，也就是RealSubject角色:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package Proxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Date: Created in 23:15 2018/7/20</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class GamePlayer implements IGamePlayer &#123;</span><br><span class="line"></span><br><span class="line">    private String name = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    public GamePlayer(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void login(String user, String password) &#123;</span><br><span class="line">        System.out.println(&quot;登录名为&quot; + user + &quot;的用户&quot; + this.name + &quot;登陆了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void killBoss() &#123;</span><br><span class="line">        System.out.println(&quot;用户&quot; + this.name + &quot;在打怪&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void upgrade() &#123;</span><br><span class="line">        System.out.println(&quot;用户&quot; + this.name + &quot;升级了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来我们的代练出场了，就是本章最重要的Proxy角色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package Proxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 静态代理实现（代理类的好处可以实现预处理和善后处理）</span><br><span class="line"> * @Date: Created in 23:19 2018/7/20</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class GamePlayerProxy implements IGamePlayer &#123;</span><br><span class="line"></span><br><span class="line">    private IGamePlayer gamePlayer = null;</span><br><span class="line"></span><br><span class="line">    public GamePlayerProxy(IGamePlayer gamePlayer) &#123;</span><br><span class="line">        this.gamePlayer = gamePlayer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void login(String user, String password) &#123;</span><br><span class="line">        this.doSomethingBefore();</span><br><span class="line">        this.gamePlayer.login(user, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void killBoss() &#123;</span><br><span class="line">        this.gamePlayer.killBoss();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void upgrade() &#123;</span><br><span class="line">        this.gamePlayer.upgrade();</span><br><span class="line">        this.doSomethingAfter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void doSomethingBefore() &#123;</span><br><span class="line">        System.out.println(&quot;代练开始&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void doSomethingAfter() &#123;</span><br><span class="line">        System.out.println(&quot;代练结束&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来我们写一个测试类来测试一下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package Proxy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 测试类</span><br><span class="line"> * @Date: Created in 23:21 2018/7/20</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        // 定义一个玩家</span><br><span class="line"></span><br><span class="line">        IGamePlayer gamePlayer = new GamePlayer(&quot;初夏倾城&quot;);</span><br><span class="line"></span><br><span class="line">        // 静态代理</span><br><span class="line">        // 定义一个代理类</span><br><span class="line">        IGamePlayer proxy = new GamePlayerProxy(gamePlayer);</span><br><span class="line"></span><br><span class="line">        proxy.login(&quot;natsu&quot;, &quot;123&quot;);</span><br><span class="line"></span><br><span class="line">        proxy.killBoss();</span><br><span class="line"></span><br><span class="line">        proxy.upgrade();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面就是我们具体的输出结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">代练开始</span><br><span class="line">登录名为natsu的用户初夏倾城登陆了</span><br><span class="line">代练结束</span><br><span class="line">用户初夏倾城在打怪</span><br><span class="line">用户初夏倾城升级了</span><br><span class="line">代练结束</span><br></pre></td></tr></table></figure></p><p>这就是一个简单的代理模式的实现。</p><h1 id="代理模式的扩展"><a href="#代理模式的扩展" class="headerlink" title="代理模式的扩展"></a>代理模式的扩展</h1><p>代理模式也分为多种，大致上可以分为静态代理和动态代理，静态代理又可以划分为普通代理和强制代理，我们先来介绍一下普通代理和强制代理，动态代理是个大Boss，我们放在最后再说，现在我们来简单介绍一下普通代理和强制代理。</p><h2 id="普通代理"><a href="#普通代理" class="headerlink" title="普通代理"></a>普通代理</h2><p>普通代理，就是要求客户端只能访问代理角色，而不能访问真实角色。我们该怎么实现呢。</p><h2 id="强制代理"><a href="#强制代理" class="headerlink" title="强制代理"></a>强制代理</h2><p>一般代理都是通过代理找到真是角色，但是强制代理确实强制的，就是你必须通过真实角色找到代理角色。<br>很典型的一个例子，我们要找一个明显拍广告，于是直接拨通了这个明星的电话，但是他却必须要求你去找他的经纪人，本来你想绕过经纪人，结果返回的还是他的经纪人，这里经纪人就是代理。就是说，你可以不必知道代理的存在，但是你所有的所作所为还是代理提供的。</p><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><h2 id="静态代理和动态代理的区别"><a href="#静态代理和动态代理的区别" class="headerlink" title="静态代理和动态代理的区别"></a>静态代理和动态代理的区别</h2><p>最重要的当然要放到最后来说，之前我们所有的代码实现都是静态代理，那么静态代理和动态代理又有什么区别呢？<br>静态代理是由程序员创建或特定工具自动生成源码，也就是说，在编译时就已经将接口、被代理类、代理类确定下来。也就是说，在程序运行之前，代理类的.class文件就已经生成。<br>静态代理有一个坏处，因为每一个代理类都需要自己去实现，所以就会造成程序中的代理类越来越多，那有什么解决方法呢，这时候就要用到动态代理。<br>动态代理的意思就是在实现阶段我们并不需要关心去代理谁，而是在运行阶段才能确定是代理哪一个对象。</p><h2 id="动态代理的简单实现"><a href="#动态代理的简单实现" class="headerlink" title="动态代理的简单实现"></a>动态代理的简单实现</h2><p>动态代理现在有两种的实现方法，一种是JDK动态代理，一种是CGLIB动态代理。<br>这两个的区别是，JDK动态代理只能对实现了接口的类生成代理，而并不能只单单针对类。<br>而CGLIB则是针对类实现代理，主要是对指定的类生成子类，覆盖其中的方法。<br>有关JDK和CGLIB实现动态代理的区别，我会单独写一篇博客记录一下，这篇博客，主要实现方法就是JDK的动态代理。<br>动态代理的主要实现需要JDK提供的动态代理接口InvocationHandler和Proxy类。<br>举个例子吧，就拿卖水果来说，以前都是水果商自己出来摆摊或者开店，但随着电商的越来越发达，很多水果商都选择将自己销售交给电商去代理，我们就用动态代理来实现一下这个例子。</p><p>先定义一个商家的接口,它有着一个销售商品的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package Proxy.DynamicProxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 商家接口</span><br><span class="line"> * @Date: Created in 11:30 2018/7/22</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public interface ISeller &#123;</span><br><span class="line"></span><br><span class="line">    void sell(String goods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后定义一个水果卖家，它有着一个私有属性sellerName，用来存储卖家名字，然后实现了ISeller的sell方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package Proxy.DynamicProxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 水果售卖商</span><br><span class="line"> * @Date: Created in 11:45 2018/7/22</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class FruitSeller implements ISeller  &#123;</span><br><span class="line"></span><br><span class="line">    String sellerName;</span><br><span class="line"></span><br><span class="line">    public FruitSeller(String sellerName) &#123;</span><br><span class="line">        this.sellerName = sellerName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void sell(String goods) &#123;</span><br><span class="line">        System.out.println(this.sellerName+&quot;卖&quot;+goods);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后定义一个动态代理类TaobaoProxy，他实现了Java提供的InvocationHandler接口，这个类中持有一个被代理对象的实例target。InvocationHandler中有一个invoke方法，所有执行代理对象的方法都会被替换成执行invoke方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package Proxy.DynamicProxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 淘宝代理销售</span><br><span class="line"> * @Date: Created in 11:46 2018/7/22</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class TaobaoProxy implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    private Object targetObject;</span><br><span class="line"></span><br><span class="line">    public TaobaoProxy(Object targetObject) &#123;</span><br><span class="line">        this.targetObject = targetObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        Object result = method.invoke(targetObject, args);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们写一个场景类来测试一下，场景类里调用了Proxy的newProxyInstance方法动态的生成了一个代理者。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package Proxy.DynamicProxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 实现场景类</span><br><span class="line"> * @Date: Created in 11:50 2018/7/22</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ISeller fruitSeller = new FruitSeller(&quot;天天果园&quot;);</span><br><span class="line"></span><br><span class="line">        // 定义一个handler</span><br><span class="line">        InvocationHandler handler = new TaobaoProxy(fruitSeller);</span><br><span class="line"></span><br><span class="line">        ISeller proxy = (ISeller) Proxy.newProxyInstance(fruitSeller.getClass().getClassLoader(), fruitSeller.getClass().getInterfaces(), handler);</span><br><span class="line"></span><br><span class="line">        proxy.sell(&quot;西瓜&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行以上代码，得到结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">天天果园卖西瓜</span><br></pre></td></tr></table></figure></p><p>这就是动态代理的简单实现了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>代理模式运用的十分广泛，往大了说一个系统框架、企业平台，往小了说，事务处理，这些地方都可能会用到代理模式。<br>Spring的AOP就是基于代理模式实现的。<br>在调试代码时，经常会看到$Proxy这样的结构，这就是一个动态代理了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.importnew.com/26116.html" target="_blank" rel="noopener">说说 JAVA 代理模式</a><br><a href="https://blog.csdn.net/carson_ho/article/details/54910472" target="_blank" rel="noopener">代理模式（Proxy Pattern）- 最易懂的设计模式解析</a><br><a href="https://www.cnblogs.com/gonjan-blog/p/6685611.html" target="_blank" rel="noopener">java动态代理实现与原理详细分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;最近在准备跳槽的面试，然后在看Spring框架原理的时候，顺便了解一下AOP的设计模式-代理模式。&lt;br&gt;&lt;br&gt;其实，代理模式在我们生活中
      
    
    </summary>
    
      <category term="设计模式" scheme="http://nastublog.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://nastublog.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-建造者模式(Builder)</title>
    <link href="http://nastublog.com/2018/07/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-Builder/"/>
    <id>http://nastublog.com/2018/07/16/设计模式-建造者模式-Builder/</id>
    <published>2018-07-16T14:49:59.000Z</published>
    <updated>2018-08-07T03:29:56.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>之前在看《Effective Java》的时候，说到对象属性比较复杂的时候考虑使用构建器构造对象，加上StringBuilder类源码的阅读，让我对建造者模式有了一定的了解，乘着刚看完《设计模式之禅》有关于建造者模式的章节，以及阅读了几位大佬的博客，写了这篇文章。</p><h1 id="建造者模式的定义"><a href="#建造者模式的定义" class="headerlink" title="建造者模式的定义"></a>建造者模式的定义</h1><p>建造者模式（Builder Pattern）的定义如下:<br><br>将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。</p><p>建造者模式具体的UML类图如下:<br><img src="/2018/07/16/设计模式-建造者模式-Builder/builder.jpg" alt="建造者模式"></p><p>在建造者模式中，有如下四个角色，在这里，我们用一个土豪定制自己的跑车的实例，分别对着四个角色进行描述:<br><br>1.Product 产品类<br>代表着具体的产品，比如，土豪的跑车，跑车有着轮胎、引擎、车身等等多重属性，一般产品类还可以联合模板方法模式，也就是说有模板方法和基本方法，这个具体可以参考模板模式，之后会写一篇专门介绍。</p><p>2.Builder 抽象建造者<br>用来规范产品的组建，而一般产品的组建是由其子类实现。在这个例子，我们可以理解为所有提供组装跑车的工厂。</p><p>3.ConcreteBuilder 具体建造者<br>实现抽象建造者定义的所有方法，并且返回一个已经组装好的对象。比如，我们这个土豪想定制一台劳斯莱斯的跑车，就需要一个专门定制劳斯莱斯跑车的工厂。</p><p>4.Director 导演类<br>负责安排已有建造顺序，并且找到对应的具体建造者。我们土豪肯定不会大费周折的去找一个劳斯莱斯的跑车工厂，所以，他会去找一个专门提供跑车定制的门店，由这个门店联系工厂，告诉工厂土豪需要什么样的跑车。</p><p>这大概就是建造者模式用到的4个类。</p><h1 id="建造者模式的具体实现"><a href="#建造者模式的具体实现" class="headerlink" title="建造者模式的具体实现"></a>建造者模式的具体实现</h1><p>既然上面我们举了这样一个例子，下面我们就来实现它吧。</p><p>先定一个跑车的产品类，有着品牌(name)、轮胎(wheel)、车身(skeleton)、引擎(enigine)四个属性，为了满足土豪装逼的心理，我们加了一个展示方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package Builder;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 跑车-产品类</span><br><span class="line"> * @Date: Created in 22:16 2018/7/16</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class Car &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private String wheel;</span><br><span class="line"></span><br><span class="line">    private String skeleton;</span><br><span class="line"></span><br><span class="line">    private String engine;</span><br><span class="line"></span><br><span class="line">    public String getWheel() &#123;</span><br><span class="line">        return wheel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setWheel(String wheel) &#123;</span><br><span class="line">        this.wheel = wheel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSkeleton() &#123;</span><br><span class="line">        return skeleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSkeleton(String skeleton) &#123;</span><br><span class="line">        this.skeleton = skeleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getEngine() &#123;</span><br><span class="line">        return engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setEngine(String engine) &#123;</span><br><span class="line">        this.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showCar()&#123;</span><br><span class="line">        System.out.println(&quot;品牌是：&quot; + name);</span><br><span class="line">        System.out.println(&quot;轮胎是：&quot; + wheel);</span><br><span class="line">        System.out.println(&quot;车身是：&quot; + skeleton);</span><br><span class="line">        System.out.println(&quot;发动机是: &quot; + engine);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><p>再来就是我们抽象的建造类，代表着所有能定制跑车的这一类工厂。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package Builder;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 抽象汽车建造方法</span><br><span class="line"> * @Date: Created in 22:14 2018/7/16</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public abstract class ICarBuilder &#123;</span><br><span class="line"></span><br><span class="line">    public abstract void buildWheel();</span><br><span class="line"></span><br><span class="line">    public abstract void buildSkeleton();</span><br><span class="line"></span><br><span class="line">    public abstract void buildEngine();</span><br><span class="line"></span><br><span class="line">    public abstract void buliderName();</span><br><span class="line"></span><br><span class="line">    public abstract Car buildCar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是我们具体的建造类，也就是劳斯莱斯的定制工厂啦。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package Builder;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 具体汽车实现类(组装人员)</span><br><span class="line"> * @Date: Created in 22:17 2018/7/16</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class ConcreteBuilder extends ICarBuilder &#123;</span><br><span class="line"></span><br><span class="line">    private Car car = new Car();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buildWheel() &#123;</span><br><span class="line">        car.setWheel(&quot;米其林轮胎&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buildSkeleton() &#123;</span><br><span class="line">        car.setSkeleton(&quot;流线型车声&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buildEngine() &#123;</span><br><span class="line">        car.setEngine(&quot;涡轮发动机&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void buliderName() &#123;</span><br><span class="line">        car.setName(&quot;劳斯莱斯&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Car buildCar() &#123;</span><br><span class="line">        return this.car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是我们和土豪直接沟通的定制车店的老板来，是由他去联系定制车的工厂的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package Builder;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description: 导演类-定制车店的老板</span><br><span class="line"> * @Date: Created in 22:20 2018/7/16</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class Director &#123;</span><br><span class="line">    public Car Construct(ICarBuilder iCarBuilder) &#123;</span><br><span class="line">        iCarBuilder.buildWheel();</span><br><span class="line">        iCarBuilder.buildSkeleton();</span><br><span class="line">        iCarBuilder.buildEngine();</span><br><span class="line">        iCarBuilder.buliderName();</span><br><span class="line">        return iCarBuilder.buildCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后写个测试类测试一下土豪买车的过程:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package Builder;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Author: qixiang.shao</span><br><span class="line"> * @Description:</span><br><span class="line"> * @Date: Created in 22:21 2018/7/16</span><br><span class="line"> * @Modified By:</span><br><span class="line"> */</span><br><span class="line">public class MainTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;我要去买车了&quot;);</span><br><span class="line">        Director director = new Director();</span><br><span class="line">        System.out.println(&quot;老板来一辆车&quot;);</span><br><span class="line">        System.out.println(&quot;找到组装工厂&quot;);</span><br><span class="line">        ICarBuilder carBuilder = new ConcreteBuilder();</span><br><span class="line">        Car myCar  = director.Construct(carBuilder);</span><br><span class="line">        System.out.println(&quot;车组装好了：&quot;);</span><br><span class="line">        System.out.println(&quot;看看我的新车吧：&quot;);</span><br><span class="line">        myCar.showCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是我们程序的输出结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">我要去买车了</span><br><span class="line">老板来一辆车</span><br><span class="line">找到组装工厂</span><br><span class="line">车组装好了：</span><br><span class="line">看看我的新车吧：</span><br><span class="line">品牌是：劳斯莱斯</span><br><span class="line">轮胎是：米其林轮胎</span><br><span class="line">车身是：流线型车声</span><br><span class="line">发动机是: 涡轮发动机</span><br></pre></td></tr></table></figure></p><p>好了，至此，我们土豪买车的过程到此结束。</p><h1 id="建造者模式的应用"><a href="#建造者模式的应用" class="headerlink" title="建造者模式的应用"></a>建造者模式的应用</h1><h2 id="建造者模式的优点"><a href="#建造者模式的优点" class="headerlink" title="建造者模式的优点"></a>建造者模式的优点</h2><p>1.封装性<br>使用建造者模式，可以让客户端不必知道产品内部的组成细节。<br>2.易于扩展<br>具体建造者ConcreteBuilder之间是相互独立的，易于扩展。<br>3.便于控制细节风险<br>由于具体的建造者式独立的，因此可以对建造的过程逐步细化，而不会对其他的模块产生影响。</p><h2 id="建造者模式的缺点"><a href="#建造者模式的缺点" class="headerlink" title="建造者模式的缺点"></a>建造者模式的缺点</h2><p>1.如果产品内部变化十分复杂的话，就会需要定义许多具体的建造者来满足这些变化，这样会让系统变得十分庞大。<br>2.适用范围有限，一般要求所创建的产品具有较多的共同点。</p><h2 id="建造者模式的使用场景"><a href="#建造者模式的使用场景" class="headerlink" title="建造者模式的使用场景"></a>建造者模式的使用场景</h2><p>1.相同的方法，不同的执行顺序，产生不同的事件结果时，就可以采用建造者模式。<br>2.需要生成的产品内部结构复杂，但是这些产品之间又具有一定的共性；<br>总之，就是在需要隔离复杂对象的创建，并且这些对象之间有相同的共性，而且不同的创建顺序会得到不同的结果的时候，就可以用到建造者模式了。</p><h1 id="建造者模式的总结"><a href="#建造者模式的总结" class="headerlink" title="建造者模式的总结"></a>建造者模式的总结</h1><p>建造者模式虽然和工厂模式同为创建型的设计模式，但本质上存在着的一定的区别，建造者模式关注的时装配的顺序，也就是说基本的方法已经实现，只是方法执行顺序不同产生的结果不同。而工厂方法的重点则是创建，创建零件是其主要职责，而装配的顺序并不是其所关心的。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/lmb55/article/details/50990732" target="_blank" rel="noopener">大话设计模式—建造者模式</a><br><a href="https://blog.csdn.net/carson_ho/article/details/54910597" target="_blank" rel="noopener">建造者模式（Builder Pattern）- 最易懂的设计模式解析</a><br><a href="https://blog.csdn.net/u013256816/article/details/50978024" target="_blank" rel="noopener">设计模式：建造者模式（Builder）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;之前在看《Effective Java》的时候，说到对象属性比较复杂的时候考虑使用构建器构造对象，加上StringBuilder类源码的阅读
      
    
    </summary>
    
      <category term="设计模式" scheme="http://nastublog.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://nastublog.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-单例模式(Singleton)</title>
    <link href="http://nastublog.com/2018/06/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-Singleton/"/>
    <id>http://nastublog.com/2018/06/30/设计模式-单例模式-Singleton/</id>
    <published>2018-06-29T17:19:38.000Z</published>
    <updated>2018-08-07T03:23:37.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>这里举个例子，古代的时候，一般只会有一个皇帝，比如秦朝。可以这样理解，皇帝是一个类，秦始皇则是一个对象实例。只会有一个皇帝实例，不然就乱套了，这在代码设计的思想中，就被称之为单例模式（Singleton Pattern）。</p><h1 id="单例模式的定义和使用场景"><a href="#单例模式的定义和使用场景" class="headerlink" title="单例模式的定义和使用场景"></a>单例模式的定义和使用场景</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>单例模式，定义如下:<br><br>确保某一个类只有一个实例，并且自行实例化并向整个系统提供这个实例。</p><h2 id="单例模式的使用场景"><a href="#单例模式的使用场景" class="headerlink" title="单例模式的使用场景"></a>单例模式的使用场景</h2><p>在一个系统中，要求一个类有且仅能有一个对象，如果出现多个对象就会出现一系列不可预知的错误，就可以采用单例模式了，具体如下:</p><p>1.定义了大量静态常量和静态方法的工具类;<br><br>2.需要生成唯一序列的环境;<br><br>3.需要频繁创建然后销毁的实例;<br><br>4.频繁访问数据库或文件的对象。<br></p><p>具体的应用场景:<br><br>1.网站的计数器，如果不是单例的话就无法实现同步;<br><br>2.Windows的任务管理器（无法打开两个任务管理器）;<br><br>3.Web应用的配置对象的读取;<br><br>4.数据库连接池;<br><br>5.Web应用配置文件的读取。<br></p><h1 id="单例模式的要素"><a href="#单例模式的要素" class="headerlink" title="单例模式的要素"></a>单例模式的要素</h1><p>如果想让一个类只拥有一个实例对象，很简单：<br><br>1.私有的构造方法，禁止外部访问;<br><br>2.私有静态引用指向实例;<br><br>3.将自己实例当做返回值的静态共有方法。<br></p><h1 id="单例模式的具体实现"><a href="#单例模式的具体实现" class="headerlink" title="单例模式的具体实现"></a>单例模式的具体实现</h1><p>单例模式,在我们平常使用中，主要有两种实现方法:饿汉式、懒汉式。</p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>何为饿汉式，饿汉，饥不择食，此处同义：在加载类的时候就会创建类的单例，并保存在类中。</p><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SingleTon &#123;</span><br><span class="line">    private static SingleTon instance = new SingleTon();</span><br><span class="line">    private SingleTon() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static SingleTon getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void say() &#123;</span><br><span class="line">        System.out.println(&quot;我是皇帝秦始皇&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为实例对象由static修饰，所以在类加载的时候就会调用私有的构造方法，创建类的单例，保存在类中。</p><p>这样做，优点是:<br><br>1.借由JVM实现了线程安全;<br><br>2.因为在类加载时就创建了类的单例，调用速度会比较快。<br></p><p>缺点也很明显，因为类加载就会创建该类的单例，不管用户是否需要，可能我们永远不会用到getInstance方法，但执行该类的其他静态方法或者加载了该类（class.forName)，那么这个实例仍然初始化，这样做会占用大量的内存资源。</p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>何为懒，就是延时，特点就是单例在类第一次被使用的时候才会构建，延时初始化。</p><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class SingleTon &#123;</span><br><span class="line">    private static SingleTon instance = null;</span><br><span class="line">    private SingleTon() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static SingleTon getInstance() &#123;</span><br><span class="line">          if (instance == null) &#123;</span><br><span class="line">              //多个线程判断instance都为null时，在执行new操作时多线程会出现重复情况</span><br><span class="line">                        instance = new SingleTon();</span><br><span class="line">                &#125;</span><br><span class="line">                return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void say() &#123;</span><br><span class="line">        System.out.println(&quot;我是皇帝秦始皇&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法相较于饿汉式的优点就是资源利用效率高，在不执行类的静态方法getInstance的时候，类的实例就不会被创建。<br>该方法的缺点在于，当系统压力增大，并发量增加的时候就可能会出现多个实例，当线程A执行到instance = new SingleTon()的时候，对象的创建是需要时间的，此时线程B执行到了if(instance == null)，判断条件也为真，于是继续执行下去，线程A获得了一个对象，线程B也获得了一个对象，在内存中就出现了两个对象。<br></p><h1 id="单例模式的额外扩展"><a href="#单例模式的额外扩展" class="headerlink" title="单例模式的额外扩展"></a>单例模式的额外扩展</h1><p>解决线程不安全的问题，可以对方法进行同步加锁，对getInstance()进行同步，代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton instance;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样做也有缺点，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。</p><p>也可以采用同步代码块的方式，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton instance;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                instance = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。</p><p>为了解决这个问题，可以采取双重加锁，就是在同步代码块内部在进行一次判断，杜绝这个问题的产生：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static volatile Singleton instance;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">             if (singleton == null) &#123;</span><br><span class="line">                    singleton = new Singleton();</span><br><span class="line">                &#125;            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法在多线程的开发中被称之为Double-Check双重检查，这样实现单例模式的方法，不仅具备了懒汉式延时加载，资源占用较少的有点，也避免了线程不安全以及同步方法效率低的缺点，是比较推荐的方式。<br>这里采用了volatile关键字保证了instance的可见性，因为Java在运行过程中分主内存和工作内存，为了效率，都是从工作内存中去读取，于是就有可能存在主内存和工作内存不一样的情况，volatile关键字的加上避免了这种情况，但是volatile不可以保证原子性，具体的话可以参考一下网上关于volatile的解析，这里不做过多解释。</p><p>单例模式还有其他的实现方式，比如静态内部类、枚举等，在这里Po一下枚举的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public void whateverMethod() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。可能是因为枚举在JDK1.5中才添加，所以在实际项目开发中，很少见人这么写过。<br>这里可以参考Blog：<br><a href="https://www.cnblogs.com/zhaoyan001/p/6365064.html" target="_blank" rel="noopener">单例模式的八种写法比较</a></p><h1 id="多例模式"><a href="#多例模式" class="headerlink" title="多例模式"></a>多例模式</h1><p>一个类想要有多个对象，很简单，new关键字就可以实现，一个类如果想只有一个对象，则可以使用单例模式，但是一个类如果想产生指定个数的对象，又该如何实现呢？<br><br>这里提供一个思路，在类里定义一个静态int变量，用来表明最多能产生的实例数量，然后定义一个List用来存放产生的对象，然后在类的静态代码块里写生成对象的逻辑，这样就可以实现一个类产生指定个数的对象。(同样，这是在类加载的时候就产生实例的)<br><br>这里举一个皇帝类作为代码的时候，具体可参照《设计模式之禅》第七章《单例模式》。</p><p>代码实现如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class Emperor &#123;</span><br><span class="line">    private static int maxEmperorNum = 2;</span><br><span class="line"></span><br><span class="line">    private static int numOfEmperorNum = 0;</span><br><span class="line"></span><br><span class="line">    private static List&lt;Emperor&gt; emperorList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private static List&lt;String&gt; emperorNameList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        for (int i = 0; i &lt; maxEmperorNum; i++) &#123;</span><br><span class="line">            emperorList.add(new Emperor(&quot;皇&quot; + （i+1） + &quot;帝&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Emperor() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Emperor(String emperorName) &#123;</span><br><span class="line">        emperorNameList.add(emperorName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 随机取得一个皇帝</span><br><span class="line">    public static Emperor getInstance() &#123;</span><br><span class="line">        Random random = new Random();</span><br><span class="line">        int numOfEmperorNum = random.nextInt(maxEmperorNum);</span><br><span class="line">        return emperorList.get(numOfEmperorNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void say() &#123;</span><br><span class="line">        System.out.println(emperorNameList.get(numOfEmperorNum));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>单例模式是23个设计模式中比较简单的模式，应用也很广泛，最最常见的，Spring中的Bean就是单例的。Spring可以管理这些Bean，决定他们什么时候创建，什么时候销毁。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;这里举个例子，古代的时候，一般只会有一个皇帝，比如秦朝。可以这样理解，皇帝是一个类，秦始皇则是一个对象实例。只会有一个皇帝实例，不然就乱套了
      
    
    </summary>
    
      <category term="设计模式" scheme="http://nastublog.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://nastublog.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
